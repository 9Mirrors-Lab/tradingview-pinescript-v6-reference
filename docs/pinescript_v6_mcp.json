[
    {
      "sections": [
        {
          "type": "Annotations",
          "heading": "Study annotation",
          "remarks": "The `study` annotation is essential for defining the basic properties of an indicator script. Only the `title` parameter is mandatory. Pine also has a `strategy` annotation function for creating backtesting strategies.",
          "examples": [
            "study(title, shorttitle, overlay, format, precision)"
          ],
          "description": "Every study (indicator) script must contain one call of the `study` annotation function. It determines the indicator’s general properties. The function signature is `study(title, shorttitle, overlay, format, precision)`. \n\n- `title`: (Mandatory) Defines the name of the indicator used in the Indicators dialog box.\n- `shorttitle`: Short name displayed on the chart, if different from `title`.\n- `overlay`: Boolean. If true, the study overlays the main chart; if false (default), it's in a separate pane. Changes require using 'Add to Chart'.\n- `format`: Defines formatting for study values. Possible values: `format.inherit` (default, uses chart settings unless `precision` is set), `format.price` (default precision \"2\" unless specified), `format.volume` (formats like \"5.183K\").\n- `precision`: Number of digits after the decimal point (0-16). If omitted, uses parent series formatting. If used with `format.inherit`, it overrides chart settings as if `format=format.price` was used.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v4/#fun_study",
            "https://www.tradingview.com/pine-script-reference/v4/#fun_strategy",
            "https://www.tradingview.com/pine-script-docs/v4/essential/strategies"
          ]
        },
        {
          "type": "Functions",
          "heading": "Declaring functions",
          "remarks": "",
          "examples": [],
          "description": "In Pine Script there is an extensive library of built-in functions which can be used to create indicators. Apart from these functions, the user is able to create his or her own personal functions in Pine.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v3/language/declaring-functions/#declaring-functions"
          ]
        },
        {
          "type": "Functions",
          "heading": "Single-line functions",
          "remarks": "Pine Scipt functions do not support recursion. It is not allowed for a function to call itself from within its own code.",
          "examples": [
            "`<identifier>(<list of arguments>) => <expression>`",
            "f(x, y) => x + y",
            "a = f(open, close)\nb = f(2, 2)\nc = f(open, 2)"
          ],
          "description": "Simple short functions are convenient to write on one line. The following is the syntax of single-line functions:\n\n`<identifier>(<list of arguments>) => <expression>`\n\nThe name of the function is located before the parentheses. Then, located in parenthesis is, which is simply a list of function arguments separated by a comma. in the example is the function’s body. The type of function return value is determined automatically and depends on arguments types of a particular function call.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v3/language/declaring-functions/#single-line-functions"
          ]
        },
        {
          "type": "Functions",
          "heading": "Multi-line functions",
          "remarks": "Indentation (4 spaces or 1 tab) is required for statements within the function body.",
          "examples": [
            "`<identifier>(<list of arguments>) =>\n    <variable declaration>\n    ...\n    <variable declaration or expression>`",
            "geom_average(x, y) =>\n    a = x*x\n    b = y*y\n    sqrt(a + b)"
          ],
          "description": "Pine Script has a syntax of declaring multiline functions:\n\n`<identifier>(<list of arguments>) =>\n    <variable declaration>\n    ...\n    <variable declaration or expression>`\n\nThe body of a multi-line function consists of a several statements. Each statement is placed on a separate line and must be preceded by 1 indentation (4 spaces or 1 tab). The indentation before the statement indicates that it is a part of the body of the function and not a part of the global scope. The first statement met that is placed without an indent (at the start of the line) will indicate that the body of the function has finished on the previous statement. Either an expression or a declared variable should be the last statement of the function’s body. The result of this expression (or variable) will be a result of the entire function’s call.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v3/language/declaring-functions/#multi-line-functions"
          ]
        },
        {
          "type": "Functions",
          "heading": "Scopes in the script",
          "remarks": "It’s possible to reference any global user variables and functions (apart from recursive calls) and built-in variables/functions from user function’s body. One can say that the local scope is embedded into the the global one. In Pine, nested functions are not allowed, i.e. one can’t declare function inside another function. All user functions are declared in the global scope. Local scopes do not intersect between one another.",
          "examples": [],
          "description": "Variables which are declared outside the body of any function belong to the _global_ scope. User-declared functions also belong to the global scope. All built-in variables and functions also belong to the global scope.\n\nEach function has its own _local_ scope. All the variables declared within the function (and the function arguments too) belong to scope of that function, meaning that it is impossible to reference them from outside — e.g., from the global scope or the local scope of another function. At the same time, from the scope of any function, it’s possible to refer to any variable declared in the global scope.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v3/language/declaring-functions/#scopes-in-the-script"
          ]
        },
        {
          "type": "Functions",
          "heading": "Functions with ‘self ref’ variables in the body",
          "remarks": "Pay attention to the use of function `nz` to prevent `na` values; they appear from the left side of the series as a result of shifting it to the right. If the last expression is a variable declaration then its value will be the function’s result.",
          "examples": [
            "study(\"Custom Simple MA\", overlay=true)\nmy_sma(src, len) =>\n    sum = nz(sum[1]) - nz(src[len]) + src\n    sum/len\nplot(my_sma(close, 9))",
            "study(\"Custom Exp MA\", overlay=true)\nmy_ema(src, len) =>\n    weight = 2.0 / (len + 1)\n    sum = nz(sum[1]) - nz(src[len]) + src\n    ma = na(src[len]) ? na : sum/len\n    out = na(out[1]) ? ma : (src - out[1]) * weight + out[1]\n    out\nplot(my_ema(close, 9))",
            "f1(x) =>\n    a = x + a[1]\n    a\nf2(x) =>\n    a = x + a[1]"
          ],
          "description": "The body of a multi-line function is a sequence of expressions and/or variable declarations. Any variable that is being declared in the body of a function can be a self referencing one (referencing its previous value using `[1]`).",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v3/language/declaring-functions/#functions-with-self-ref-variables-in-the-body"
          ]
        },
        {
          "type": "Functions",
          "heading": "Functions that return multiple result",
          "remarks": "",
          "examples": [
            "fun(x, y) =>\n    a = x+y\n    b = x-y\n    [a, b]",
            "[res0, res1] = fun(open, close)\nplot(res0)\nplot(res1)"
          ],
          "description": "In most cases a function returns one result. But it is possible to return a list of results (a _tuple_-like result) using square brackets `[]`. There is a special syntax for calling such functions and assigning the results to multiple variables.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v3/language/declaring-functions/#functions-that-return-multiple-result"
          ]
        },
        {
          "type": "Functions",
          "heading": "Single-line functions",
          "remarks": "The type of the value returned by function `f` is determined automatically and depends on the type of the arguments used in each particular function call. In the example above, the type of variable `a` is _series_ because the arguments are both _series_. The type of variable `b` is _integer_ because arguments are both _literal integers_. The type of variable `c` is _series_ because the addition of a _series_ and _literal integer_ produces a _series_ result.\n\nPine Scipt functions do not support recursion. It is **not allowed** for a function to call itself from within its own code.",
          "examples": [
            "f(x, y) => x + y",
            "a = f(open, close)\nb = f(2, 2)\nc = f(open, 2)"
          ],
          "description": "Simple functions can often be written on one line. This is the syntax of single-line functions:\n\n```\n<identifier>(<list of arguments>) => <expression>\n```",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v4/language/declaring-functions/#single-line-functions"
          ]
        },
        {
          "type": "Functions",
          "heading": "Multi-line functions",
          "remarks": "Either an expression or a declared variable should be the last statement of the function’s body. The result of this expression (or variable) will be the result of the function’s call. For example:\n\nThe function `geom_average` has two arguments and creates two variables in the body: `a` and `b`. The last statement calls the function `sqrt` (an extraction of the square root). The `geom_average` call will return the value of the last expression: `(sqrt(a + b))`.",
          "examples": [
            "geom_average(x, y) =>\n    a = x*x\n    b = y*y\n    sqrt(a + b)"
          ],
          "description": "Pine also supports multi-line functions with the following syntax:\n\n```\n<identifier>(<list of arguments>) =>\n    <variable declaration>\n    ...\n    <variable declaration or expression>\n```\n\nThe body of a multi-line function consists of several statements. Each statement is placed on a separate line and must be preceded by 1 indentation (4 spaces or 1 tab). The indentation before the statement indicates that it is a part of the body of the function and not part of the script’s global scope. After the function’s code, the first statement without an indent indicates the body of the function has ended.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v4/language/declaring-functions/#multi-line-functions"
          ]
        },
        {
          "type": "Functions",
          "heading": "Scopes in the script",
          "remarks": "In Pine, nested functions are not allowed, i.e., one cannot declare a function inside another one. All user functions are declared in the global scope. Local scopes cannot intersect with each other.",
          "examples": [],
          "description": "Variables declared outside the body of a function or of other local blocks belong to the _global_ scope. User-declared and buit-in functions, as well as built-in variables also belong to the global scope.\n\nEach function has its own _local_ scope. All the variables declared within the function, as well as the function’s arguments, belong to the scope of that function, meaning that it is impossible to reference them from outside - e.g., from the global scope or the local scope of another function.\n\nOn the other hand, since it is possible to refer to any variable or function declared in the global scope from the scope of a function (except for self-referencing recursive calls), one can say that the local scope is embedded into the global scope.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v4/language/declaring-functions/#scopes-in-the-script"
          ]
        },
        {
          "type": "Functions",
          "heading": "Functions that return multiple results",
          "remarks": "Special syntax is required for calling such functions:",
          "examples": [
            "fun(x, y) =>\n    a = x+y\n    b = x-y\n    [a, b]",
            "[res0, res1] = fun(open, close)\nplot(res0)\nplot(res1)"
          ],
          "description": "In most cases a function returns only one result, but it is possible to return a list of results (a _tuple_-like result):",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v4/language/declaring-functions/#functions-that-return-multiple-results"
          ]
        },
        {
          "type": "Operators",
          "heading": "Arithmetic operators",
          "remarks": "If at least one operand is `na`, the result is also `na`.",
          "examples": [],
          "description": "There are five arithmetic operators in Pine Script: `+` (Addition), `-` (Subtraction), `*` (Multiplication), `/` (Division), `%` (Modulo). These operators are binary. The result type depends on the operand types: if at least one is a series, the result is a series; if at least one is float (and both numeric), the result is float; if both are integers, the result is integer.",
          "related_links": []
        },
        {
          "type": "Operators",
          "heading": "Comparison operators",
          "remarks": "",
          "examples": [],
          "description": "There are six comparison operators in Pine Script: `<` (Less Than), `<=` (Less Than or Equal To), `!=` (Not Equal), `==` (Equal), `>` (Greater Than), `>=` (Greater Than or Equal). These operations are binary. If at least one operand is a series, the result is a series of boolean values. If both operands are numeric, the result is a single boolean value (`bool`).",
          "related_links": []
        },
        {
          "type": "Operators",
          "heading": "Logical operators",
          "remarks": "",
          "examples": [],
          "description": "There are three logical operators: `not` (Negation), `and` (Logical Conjunction), `or` (Logical Disjunction). They operate on `bool`, numerical, or series operands. If at least one operand is a series, the result is a series. Otherwise, the result is `bool`. `not` is unary, inverting `true` to `false` and vice versa. Truth tables for `and` and `or` are provided.",
          "related_links": []
        },
        {
          "type": "Operators",
          "heading": "Conditional operator ?: and the function iff",
          "remarks": "Nested conditional operators allow for complex conditional logic similar to switch statements.",
          "examples": [
            "condition ? result1 : result2",
            "isintraday ? red : isdaily ? green : ismonthly ? blue : na",
            "isintraday ? red : (isdaily ? green : (ismonthly ? blue : na))",
            "iff(condition, result1, result2)",
            "iff(isintraday, red, iff(isdaily, green, iff(ismonthly, blue, na)))"
          ],
          "description": "The conditional ternary operator `?:` evaluates a condition and returns one of two results based on whether the condition is true or false. Syntax: `condition ? result1 : result2`. If `condition` is true, `result1` is returned; otherwise, `result2` is returned. Multiple operators can be nested to create switch-like structures. The built-in function `iff(condition, result1, result2)` provides equivalent functionality.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v3/#op_%7Bquestion%7D%7Bcolon%7D"
          ]
        },
        {
          "type": "Operators",
          "heading": "History reference operator []",
          "remarks": "Applying the `[]` operator multiple times to the same operand (e.g., `close[1][2]`) is prohibited. Negative arguments are not allowed; use the `offset` argument in `plot` for visual shifting. Code should handle potential `na` values, often using `na` or `nz` functions, as calculations involving `na` result in `na`.",
          "examples": [
            "sma(close, 10)[1]",
            "close[1][2] // Error: incorrect use of operator []"
          ],
          "description": "The history reference operator `[]` allows accessing previous values (historical data) of series variables. For example, `close[1]` refers to the value of `close` on the previous bar. When shifting, `na` (not available) values are introduced at the beginning of the series. This operator can be applied to series results from function calls, like `sma(close, 10)[1]`.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v3/#fun_plot",
            "https://www.tradingview.com/pine-script-docs/v3/language/expressions-declarations-and-statements#preventing-na-values-functions-na-and-nz",
            "https://en.wikipedia.org/wiki/NaN"
          ]
        },
        {
          "type": "Operators",
          "heading": "Priority of operators",
          "remarks": "A table lists operators sorted by decreasing priority: `[]` (highest), unary `+`/`-`/`not`, `*` / `/` / `%`, `+` / `-`, comparison operators (`>`, `<`, `>=`, `<=`), equality operators (`==`, `!=`), `and`, `or` (lowest).",
          "examples": [],
          "description": "The order of calculations in expressions is determined by operator priority. Operators with higher priority are evaluated first. Operators with the same priority are evaluated from left to right. Parentheses `()` can be used to override the default order of operations.",
          "related_links": []
        },
        {
          "type": "Functions",
          "heading": "Can I use a variable length in functions?",
          "remarks": "For built-in functions that do not accept “series” lengths and for which the functionality is not available in the ta library, consider creating a user-defined function. The ta library offers extended TA-related capabilities and custom implementations.",
          "examples": [],
          "description": "Explains that many built-in Technical Analysis (TA) functions accept \"series\" lengths (variable), while some only accept \"simple\" integer lengths (constant). Recommends checking the Reference Manual entry for a function to determine the type of values it can process.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/built-ins#built-in-functions",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#series",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#simple",
            "https://www.tradingview.com/script/BICzyhq0-ta/",
            "https://www.tradingview.com/pine-script-docs/language/user-defined-functions/"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I calculate values depending on variable lengths that reset on a condition?",
          "remarks": "Before the condition is met for the first time, `ta.barssince()` returns `na`. Use `nz()` to replace `na` with zero for early bars. When the condition is met, `ta.barssince()` returns zero; add one to this value if using it as a length, as lengths cannot be zero. The example script calculates the highest and lowest price points since the start of a new day using `timeframe.change()` as the condition.",
          "examples": [
            "//@version=6\nindicator(\"Highest/lowest since new day\", \"\", true)\n// Identify the start of a new day and calculate the number of bars since then.\nbool newDay  = timeframe.change(\"D\")\nint lookback = nz(ta.barssince(newDay)) + 1\n// Calculate the highest and lowest point since the new day began.\nfloat lowestSinceNewDay  = ta.lowest(lookback)\nfloat highestSinceNewDay = ta.highest(lookback)\n// Plot the high/low level since the start of a new day.\nplot(lowestSinceNewDay, \"High today\", color.orange)\nplot(highestSinceNewDay, \"Low today\", color.aqua)\n// Change the background color to indicate the start of a new day.\nbgcolor(newDay ? color.new(color.gray, 80) : na)\n// Display the varying lookback period in Data Window.\nplot(lookback, \"Lookback\", display = display.data_window)"
          ],
          "description": "Explains how to use the `ta.barssince()` function to calculate values dependent on varying lengths that reset under specific conditions. This function counts the number of bars since the last occurrence of a specified condition.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.barssince",
            "https://www.tradingview.com/pine-script-reference/v6/#var_na",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_nz",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_timeframe.change",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.lowest",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I round a number to x increments?",
          "remarks": "This technique is useful for tasks like calculating levels for grid trading, dealing with fractional shares, or aligning trading parameters to specific pip values. The function works by dividing the value by the increment, rounding the result, and then multiplying by the increment.",
          "examples": [
            "//@version=6\nindicator(\"Round to x increment demo\", overlay = true)\nfloat incrementInput = input.float(0.75, \"Increment\", step = 0.25)\n// @function               Rounds a value to the nearest multiple of a specified increment.\n// @param value            The value to round.\n// @param increment        The increment to round the value to.\n// @returns                The rounded value.\nroundToIncrement(value, increment) =>\n    math.round(value / increment) * increment\nplot(series = roundToIncrement(close, incrementInput), color = chart.fg_color)"
          ],
          "description": "Provides a user-defined function `roundToIncrement()` that rounds a given value to the nearest multiple of a specified increment.",
          "related_links": []
        },
        {
          "type": "Functions",
          "heading": "How can I control the precision of values my script displays?",
          "remarks": "By default, scripts use the precision of the chart's price scale. To display more decimal places, specify a `precision` argument value greater than the current price scale's precision.",
          "examples": [],
          "description": "Explains that the `precision` and `format` arguments within the `indicator()` or `strategy()` declaration statement control the number of decimal places displayed for values in a script.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_indicator",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_strategy"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I control the precision of values used in my calculations?",
          "remarks": "Use the `math.round(number, precision)` variation of `math.round()` to round values to a specified precision. Alternatively, use `math.round_to_mintick()` to round values to the nearest tick precision of the chart’s symbol.",
          "examples": [],
          "description": "Describes how to control the precision of numbers used within script calculations using specific functions.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_math.round",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_math.round_to_mintick"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I round to ticks?",
          "remarks": "To convert the resulting number rounded to tick precision into a string, use the format `str.tostring(myValue, format.mintick)`.",
          "examples": [],
          "description": "Explains how to round numerical values to the tick precision of the chart's symbol using the `math.round_to_mintick()` function.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_math.round_to_mintick"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I abbreviate large values?",
          "remarks": "Methods include: 1) Applying a global setting using `format = format.volume` in `indicator()` or `strategy()` statements. 2) Abbreviating specific values for string display using `str.tostring(value, format.volume)`. 3) Using a custom user-defined function for specific precision or abbreviation up to trillions, as shown in the example.",
          "examples": [
            "//@version=6\nindicator(\"Value abbreviation example\")\n// @function           Converts a numeric value into a readable string representation featuring the appropriate order\n//                       of magnitude abbreviation (K, M, B, T).\n// @param value        (float) The value to format.\n// @param precision        (string) The numerical precision of the result. (\\\"\\\" for none, \\\".00\\\" for two digits, etc.)\n// @returns                (string) The formatted value as a string with the appropriate abbreviation suffix.\nabbreviateValue(float value, string precision) =>\n    float digitsAmt = math.log10(math.abs(value))\n    string formatPrecision = \"#\" + precision\n    string result = switch\n        digitsAmt > 12 => str.tostring(value / 1e12, formatPrecision + \"\\u200a\\u200aT\")\n        digitsAmt > 9  => str.tostring(value / 1e9,  formatPrecision + \"\\u200a\\u200aB\")\n        digitsAmt > 6  => str.tostring(value / 1e6,  formatPrecision + \"\\u200a\\u200aM\")\n        digitsAmt > 3  => str.tostring(value / 1e3,  formatPrecision + \"\\u200a\\u200aK\")\n        =>               str.tostring(value, \"#\" +  formatPrecision)\nprint(formattedString) =>\n    var table t = table.new(position.middle_right, 1, 1)\n    table.cell(t, 0, 0, formattedString, bgcolor = color.yellow)\nprint(abbreviateValue(volume, \".00\"))"
          ],
          "description": "Discusses various methods for abbreviating large numerical values, such as volume, into shorter forms like 1.222M instead of 1,222,333.0.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_indicator",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_strategy",
            "https://www.tradingview.com/pine-script-docs/language/user-defined-functions/"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I calculate using pips?",
          "remarks": "The function checks `syminfo.type`, `syminfo.currency`, and `syminfo.basecurrency` to determine the appropriate value, considering special cases for JPY pairs. For non-forex symbols, it returns `syminfo.mintick`.",
          "examples": [
            "//@version=6\nindicator(\"Pip calculation example\")\n// @function           Calculates the chart symbol's base unit of change in asset prices.\n// @returns            (float) A ticks or pips value of base units of change.\ncalcBaseUnit() =>\n    bool isForexSymbol = syminfo.type         == \"forex\"\n    bool isYenQuote    = syminfo.currency     == \"JPY\"\n    bool isYenBase     = syminfo.basecurrency == \"JPY\"\n    float result = isForexSymbol ? isYenQuote ? 0.01 : isYenBase ? 0.00001 : 0.0001 : syminfo.mintick\n// Call the function and plot the result in a label\nvar label baseUnitLabel = na\nif barstate.islast\n    baseUnitLabel := label.new(x=bar_index + 1, y=open, text=\"Base Unit: \" + str.tostring(calcBaseUnit(), \"#.######\"),\n      style=label.style_label_left, color=color.new(color.blue, 0), textcolor=color.white)\n    label.delete(baseUnitLabel[1])"
          ],
          "description": "Provides a custom user-defined function, `calcBaseUnit()`, designed to return the correct pip value for Forex symbols or the base unit of change (minimum tick) for non-forex symbols.",
          "related_links": []
        },
        {
          "type": "Functions",
          "heading": "How do I calculate averages?",
          "remarks": "Use `math.avg()` for a small number of distinct variables. Use built-in variables `hl2`, `hlc3`, or `ohlc4` for single bar average prices. Use `ta.sma(series, n)` for the average of the last n values in a series. For custom datasets, use `array.avg()` for arrays or `matrix.avg()` for matrices. Refer to the linked publication for conditional averages.",
          "examples": [],
          "description": "Outlines various methods for calculating averages in Pine Script™, depending on the type of data being averaged.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_math.avg",
            "https://www.tradingview.com/pine-script-reference/v6/#var_hl2",
            "https://www.tradingview.com/pine-script-reference/v6/#var_hlc3",
            "https://www.tradingview.com/pine-script-reference/v6/#var_ohlc4",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma",
            "https://www.tradingview.com/pine-script-docs/language/arrays/",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_array.avg",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_matrix.avg",
            "https://www.tradingview.com/script/9l0ZpuQU-ConditionalAverages/"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I calculate an average only when a certain condition is true?",
          "remarks": "Standard averaging methods apply to all data points. For conditional averages, custom functions are needed. The example script imports the `ConditionalAverages` library and uses its `avgWhen()` and `avgWhenLast()` functions to calculate the average volume specifically for session opening bars, identified by the `session.isfirstbar_regular` condition.",
          "examples": [
            "//@version=6\nindicator(\"Average session opening volume\")\nimport PineCoders/ConditionalAverages/1 as PCca\n// Color aqua for the session's opening bar, otherwise distinct colors for up/down volume columns.\ncolor volumeColor = switch\n    session.isfirstbar_regular => color.aqua\n    close > open               => color.new(#D1D4DC, 65)\n    =>                           color.new(#787B86, 65)\n// Plot the volume columns.\nplot(volume, \"volume\", volumeColor, 4, plot.style_histogram)\n// Average volume over *all* session opening bars in the dataset.\nplot(PCca.avgWhen(src = volume, cond = session.isfirstbar_regular), \"avg. When\", #FF00FF)\n// Average volume over the last five opening bars.\nplot(PCca.avgWhenLast(src = volume, cond = session.isfirstbar_regular, cnt = 5), \"avgWhenInLast()\", #00FF00)"
          ],
          "description": "Explains how to calculate averages based only on values that meet a specific condition, known as conditional averages, using custom functions or libraries.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/faq/functions#how-do-i-calculate-averages",
            "https://www.tradingview.com/pine-script-docs/concepts/libraries/",
            "https://www.tradingview.com/script/9l0ZpuQU-ConditionalAverages/",
            "https://www.tradingview.com/pine-script-reference/v6/#var_session.isfirstbar_regular"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I generate a random number?",
          "remarks": "The example script generates a random y-value between 0 and 1 (the default range for `math.random()`) and a random RGB color by calling `math.random(0, 255)` three times for the red, green, and blue components.",
          "examples": [
            "//@version=6\nindicator(\"Random demo\", overlay = false)\n// Generate a random price value (the default range is 0 to 1).\nfloat y = math.random()\n// Generate a color with red, green, and blue values as separate random values between 0 and 255.\ncolor plotColor = color.rgb(math.random(0, 255), math.random(0, 255), math.random(0, 255))\nplot(series = y, title = \"Random number\", color = plotColor, linewidth = 2, style = plot.style_circles)"
          ],
          "description": "Demonstrates how to generate pseudo-random numbers in Pine Script™ using the `math.random()` function.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_math.random"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I evaluate a filter I am planning to use?",
          "remarks": "Insert the filter code into the 'Filter Information Box - PineCoders FAQ' script. This script performs an impulse response analysis and displays the filter's characteristics in a label on the chart. Refer to the script's publication description for guidance on integration.",
          "examples": [],
          "description": "Suggests a method for evaluating the characteristics of a custom filter intended for use in a Pine Script™.",
          "related_links": [
            "https://www.tradingview.com/script/oTEP9DJF-Filter-Information-Box-PineCoders-FAQ/"
          ]
        },
        {
          "type": "Functions",
          "heading": "What does nz() do?",
          "remarks": "`nz()` is crucial for preventing `na` values from propagating through calculations, which can happen, for example, when referencing historical data on the first bar (`close[1]`). It is also useful to protect against potential divide-by-zero errors by ensuring a non-`na` return value (typically zero) even if the denominator is zero.",
          "examples": [
            "//@version=6\nindicator(\"`na` values on first bar demo\")\nbool useNzInput = input.bool(true, \"Use `nz` to ensure value is never na\")\n// This variable is na on the first bar.\nfloat barRangeRaw = close - close[1]\n// This variable is never na.\nfloat barRangeWithNz = close - nz(close[1], open)\n// Choose the value to use based on the input\nfloat barRange = useNzInput ? barRangeWithNz : barRangeRaw\n// Perform a calculation that depends on the barRange\nvar float dependentCalculation = 0\ndependentCalculation := ((dependentCalculation + barRange)/2)\n// Plot the results\nplot(dependentCalculation, title=\"Average Bar Range\")",
            "float dbzTest = nz(close / (close - close))"
          ],
          "description": "Explains the purpose and usage of the `nz()` function in Pine Script™. It replaces `na` (Not Available) values with zero by default, or with a specified replacement value.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_nz",
            "https://www.tradingview.com/pine-script-reference/v6/#var_na"
          ]
        },
        {
          "type": "Functions",
          "heading": "Introduction",
          "remarks": "Key characteristics: Cannot be embedded, no recursion support, return type determined automatically based on arguments, return value is the last value in the function body, each call instance maintains independent history.",
          "examples": [],
          "description": "Introduces user-defined functions in Pine Script®, explaining their purpose, how they can be written (single-line or multi-line), and where they can be located (within the script or in libraries).",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v5/writing/style-guide/#function_declarations",
            "https://www.tradingview.com/pine-script-docs/v5/concepts/libraries/"
          ]
        },
        {
          "type": "Functions",
          "heading": "Single-line functions",
          "remarks": "Formal definition: `<identifier>(<parameter_list>) => <return_value>`. The return type depends on the types of arguments used in the specific function call.",
          "examples": [
            "f(x, y) => x + y",
            "a = f(open, close)",
            "b = f(2, 2)",
            "c = f(open, 2)"
          ],
          "description": "Explains the syntax and usage of simple user-defined functions that can be written in a single line.",
          "related_links": []
        },
        {
          "type": "Functions",
          "heading": "Multi-line functions",
          "remarks": "Syntax: `<identifier>(<parameter_list>) => <local_block>`. Each statement is on a separate line preceded by 1 indentation (4 spaces or 1 tab). The result of the last statement (expression or variable) is returned.",
          "examples": [
            "geom_average(x, y) =>\n    a = x*x\n    b = y*y\n    math.sqrt(a + b)"
          ],
          "description": "Details the syntax for defining functions that span multiple lines, requiring indentation for the function body.",
          "related_links": []
        },
        {
          "type": "Functions",
          "heading": "Scopes in the script",
          "remarks": "Variables declared outside functions belong to the global scope. Each function has its own local scope containing its arguments and locally declared variables. Local scopes can access the global scope but not each other. Nested function declarations are disallowed.",
          "examples": [],
          "description": "Explains the concept of global and local scopes within Pine Script, especially concerning user-defined functions.",
          "related_links": []
        },
        {
          "type": "Functions",
          "heading": "Functions that return multiple results",
          "remarks": "Functions return multiple values by enclosing them in square brackets `[]`. A special syntax `[var1, var2] = function_call(...)` is used to assign the returned values.",
          "examples": [
            "fun(x, y) =>\n    a = x+y\n    b = x-y\n    [a, b]",
            "[res0, res1] = fun(open, close)\nplot(res0)\nplot(res1)"
          ],
          "description": "Describes how user-defined functions can return multiple results using a tuple-like structure.",
          "related_links": []
        },
        {
          "type": "Functions",
          "heading": "Limitations",
          "remarks": "User-defined functions cannot use certain built-ins like `barcolor()`, `fill()`, `hline()`, `indicator()`, `library()`, `plot()`, `plotbar()`, `plotcandle()`, `plotchar()`, `plotshape()`, and `strategy()`.",
          "examples": [],
          "description": "Lists the built-in Pine Script® functions that are not permitted to be called from within user-defined functions.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#fun_barcolor",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_fill",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_hline",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_indicator",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_library",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_plot",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_plotbar",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_plotcandle",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_plotchar",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_plotshape",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_strategy"
          ]
        },
        {
          "type": "Types",
          "heading": "Qualifiers",
          "remarks": "Qualifiers determine when values are accessible and follow a hierarchy: const < input < simple < series. Expressions adopt the dominant qualifier. Only 'series' values can change across executions.",
          "examples": [],
          "description": "Pine Script® _qualifiers_ identify when values are accessible to a script:\n\n- Values and references qualified as [const](https://www.tradingview.com/pine-script-docs/language/type-system/#const) are established at compile time (i.e., when saving the script in the Pine Editor or adding it to the chart).\n- Values qualified as [input](https://www.tradingview.com/pine-script-docs/language/type-system/#input) are established at input time (i.e., when confirming values based on user input, primarily from the “Settings/Inputs” tab).\n- Values qualified as [simple](https://www.tradingview.com/pine-script-docs/language/type-system/#simple) are established at bar zero (i.e., the first script execution).\n- Values qualified as [series](https://www.tradingview.com/pine-script-docs/language/type-system/#series) can change throughout the script’s executions.\n\nPine Script bases the dominance of type qualifiers on the following hierarchy: **const < input < simple < series**, where “const” is the _weakest_ qualifier and “series” is the _strongest_. The qualifier hierarchy translates to this rule: whenever a variable, function, or operation is compatible with a specific qualified type, values with _weaker_ qualifiers are also allowed.\n\nScripts always qualify their expressions’ returned types based on the _dominant qualifier_ in their calculations. For example, evaluating an expression that involves “input” and “series” values will return a value qualified as “series”. Furthermore, scripts **cannot** change a value’s qualifier to one that’s _lower_ on the hierarchy. If a value acquires a _stronger_ qualifier (e.g., a value initially inferred as “simple” becomes “series” later in the script’s executions), that state is irreversible.\n\nIt’s important to note that “series” values are the **only** ones that can change across script executions, including those from various built-ins, such as [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) and [volume](https://www.tradingview.com/pine-script-reference/v6/#var_volume), as well as the results of expressions involving “series” values. All values qualified as “const”, “input”, or “simple” remain consistent across all script executions.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/type-system/#const",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#input",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#simple",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#series",
            "https://www.tradingview.com/pine-script-reference/v6/#var_close",
            "https://www.tradingview.com/pine-script-reference/v6/#var_volume"
          ]
        },
        {
          "type": "Constants",
          "heading": "const",
          "remarks": "'const' values are established at compile time and never change. Literals are 'const'. The 'const' keyword prevents reassignment but doesn't guarantee the referenced value itself isn't dynamic (e.g., a 'series' ID).",
          "examples": [
            "//@version=6\n// The following global variables are all of the \"const string\" qualified type:\n//@variable The title of the indicator.\nINDICATOR_TITLE = \"const demo\"\n//@variable The title of the first plot.\nvar PLOT1_TITLE = \"High\"\n//@variable The title of the second plot.\nconst string PLOT2_TITLE = \"Low\"\n//@variable The title of the third plot.\nPLOT3_TITLE = \"Midpoint between \" + PLOT1_TITLE + \" and \" + PLOT2_TITLE\nindicator(INDICATOR_TITLE, overlay = true)\nplot(high, PLOT1_TITLE)\nplot(low, PLOT2_TITLE)\nplot(hl2, PLOT3_TITLE)",
            "//@version=6\n//@variable The title in the `indicator()` call.\nvar NAME = \"My indicator for \" + syminfo.ticker\nindicator(NAME, \"\", true) // Causes an error because `NAME` is qualified as a \"simple string\".\nplot(close)",
            "//@version=6\nindicator(\"Cannot reassign const demo\")\n//@variable A \"float\" variable declared as `const`, preventing reassignment.\nconst float myVar = 0.0\nmyVar += 1.0 // Causes an error. Reassignment and compound assignments are not allowed on `const` variables.\nplot(myVar)",
            "//@version=6\nindicator(\"Constant reference to 'series' ID demo\")\n//@variable A `label` variable declared as `const`, preventing reassignment.\n//         Although the reference is constant, the ID of the `label` is a \"series\" value.\nconst label myVar = label.new(bar_index, close)"
          ],
          "description": "Values or references qualified as “const” are established at _compile_ _time_, before the script starts its executions. Compilation initially occurs when saving a script in the Pine Editor, which does not require it to run on a chart. Values or references with the “const” qualifier _never change_ between script executions, not even on the first execution.\n\nAll _literal_ values and the results returned by expressions involving only values qualified as “const” automatically adopt the “const” qualifier.\n\nThese are some examples of literal values:\n\n- _literal int_: `1`, `-1`, `42`\n- _literal float_: `1.`, `1.0`, `3.14`, `6.02E-23`, `3e8`\n- _literal bool_: `true`, `false`\n- _literal color_: `#FF55C6`, `#FF55C6ff`\n- _literal string_: `\"A text literal\"`, `\"Embedded single quotes 'text'\"`, `'Embedded double quotes \"text\"'`\n\nOur [Style guide](https://www.tradingview.com/pine-script-docs/writing/style-guide/) recommends using uppercase SNAKE_CASE to name “const” variables for readability. While not a requirement, one can also use the [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var) keyword when declaring “const” variables so the script only initializes them on the _first bar_ of the dataset. See [this section](https://www.tradingview.com/pine-script-docs/language/variable-declarations/#var) of our User Manual for more information.\n\nThe [const](https://www.tradingview.com/pine-script-reference/v6/#type_const) keyword allows the declaration of variables and parameters with constant _value assignments_. Declaring a variable with this keyword instructs the script to forbid using _reassignment_ and _compound assignment_ operations on it.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/writing/style-guide/",
            "https://www.tradingview.com/pine-script-reference/v6/#kw_var",
            "https://www.tradingview.com/pine-script-docs/language/variable-declarations/#var",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_indicator",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_plot",
            "https://www.tradingview.com/pine-script-reference/v6/#var_syminfo.ticker",
            "https://www.tradingview.com/pine-script-reference/v6/#type_const",
            "https://www.tradingview.com/pine-script-reference/v6/#op_+="
          ]
        },
        {
          "type": "Variables",
          "heading": "input",
          "remarks": "'input' values are established at input time, typically via `input.*()` functions, and are user-configurable. Changing inputs restarts the script.",
          "examples": [
            "//@version=6\nindicator(\"input demo\", overlay = true)\n//@variable The symbol to request data from. Qualified as \"input string\".\nsymbolInput = input.symbol(\"AAPL\", \"Symbol\")\n//@variable The timeframe of the data request. Qualified as \"input string\".\ntimeframeInput = input.timeframe(\"D\", \"Timeframe\")\n//@variable The source of the calculation. Qualified as \"series float\".\nsourceInput = input.source(close, \"Source\")\n//@variable The `sourceInput` value from the requested context. Qualified as \"series float\".\nrequestedSource = request.security(symbolInput, timeframeInput, sourceInput)\nplot(requestedSource)"
          ],
          "description": "Most values qualified as “input” are established after initialization via the `input.*()` functions. These functions produce values that users can modify within the “Inputs” tab of the script’s settings. When one changes any of the values in this tab, the script _restarts_ from the beginning of the chart’s history to ensure its inputs are consistent throughout its executions. Some of Pine’s built-in variables, such as [chart.bg_color](https://www.tradingview.com/pine-script-reference/v6/#var_chart.bg_color) also use the “input” qualifier, even though `input.*()` functions do not return them, since the script receives their values at _input time_.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_chart.bg_color",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_request.security"
          ]
        },
        {
          "type": "Variables",
          "heading": "simple",
          "remarks": "'simple' values are established on the first script execution (bar zero) and remain constant thereafter. The `simple` keyword can be used for explicit declaration. Many built-ins return 'simple' values.",
          "examples": [
            "//@version=6\nindicator(\"simple demo\", overlay = true)\n//@variable Is `true` when the current chart is non-standard. Qualified as \"simple bool\".\nisNonStandard = not chart.is_standard\n//@variable Is orange when the the current chart is non-standard. Qualified as \"simple color\".\nsimple color warningColor = isNonStandard ? color.new(color.orange, 70) : na\n// Colors the chart's background to warn that it's a non-standard chart type.\nbgcolor(warningColor, title = \"Non-standard chart color\")"
          ],
          "description": "Values qualified as “simple” are available on the first script execution, and they remain consistent across subsequent executions.\n\nUsers can explicitly define variables and parameters that accept “simple” values by including the `simple` keyword in their declaration.\n\nMany built-in variables return “simple” qualified values because they depend on information that a script can only obtain once it starts running on the chart. Additionally, many built-in functions require “simple” arguments that do not change over time. Wherever a script allows “simple” values, it can also accept values qualified as “input” or “const”.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_chart.is_standard",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor"
          ]
        },
        {
          "type": "Variables",
          "heading": "series",
          "remarks": "'series' values can change on each script execution. Built-in price/volume variables, time, bar_index, and results involving them or historical lookups ([]) are 'series'. The `series` keyword can be used for explicit declaration. 'series' is the highest qualifier.",
          "examples": [
            "//@version=6\nindicator(\"series demo\", overlay = true)\n//@variable The source value to calculate on. Qualified as \"series float\".\nseries float sourceInput = input.source(close, \"Source\")\n//@variable The number of bars in the calculation. Qualified as \"input int\".\nlengthInput = input.int(20, \"Length\")\n//@variable The highest `sourceInput` value over `lengthInput` bars. Qualified as \"series float\".\nseries float highest = ta.highest(sourceInput, lengthInput)\n//@variable The lowest `sourceInput` value over `lengthInput` bars. Qualified as \"series float\".\nlowest = ta.lowest(sourceInput, lengthInput)\nplot(highest, \"Highest source\", color.green)\nplot(lowest, \"Lowest source\", color.red)"
          ],
          "description": "Values qualified as “series” provide the most flexibility in scripts since they can change across executions.\n\nUsers can explicitly define variables and parameters that accept “series” values by including the `series` keyword in their declarations.\n\nBuilt-in variables such as [open](https://www.tradingview.com/pine-script-reference/v6/#var_open), [high](https://www.tradingview.com/pine-script-reference/v6/#var_high), [low](https://www.tradingview.com/pine-script-reference/v6/#var_low), [close](https://www.tradingview.com/pine-script-reference/v6/#var_close), [volume](https://www.tradingview.com/pine-script-reference/v6/#var_volume), [time](https://www.tradingview.com/pine-script-reference/v6/#var_time), and [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index), and the result from any expression using such built-ins, are qualified as “series”. The result of any function or operation that returns a dynamic value will always be a “series”, as will the results from using the history-referencing operator [[]](https://www.tradingview.com/pine-script-reference/v6/#op_%5B%5D) to access historical values. Wherever a script allows “series” values, it will also accept values with any other qualifier, as “series” is the _highest_ qualifier on the hierarchy.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_open",
            "https://www.tradingview.com/pine-script-reference/v6/#var_high",
            "https://www.tradingview.com/pine-script-reference/v6/#var_low",
            "https://www.tradingview.com/pine-script-reference/v6/#var_close",
            "https://www.tradingview.com/pine-script-reference/v6/#var_volume",
            "https://www.tradingview.com/pine-script-reference/v6/#var_time",
            "https://www.tradingview.com/pine-script-reference/v6/#var_bar_index",
            "https://www.tradingview.com/pine-script-reference/v6/#op_%5B%5D",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.lowest"
          ]
        },
        {
          "type": "Types",
          "heading": "Types",
          "remarks": "Types classify values. Includes fundamental (int, float, bool, color, string), special (plot, hline, drawings, collections, chart.point), user-defined (UDTs), enums, and void. Special types and UDTs use IDs. Auto-casting: int → float → bool. Type keywords (int, float, etc.) allow explicit type declaration.",
          "examples": [
            "//@version=6\nindicator(\"Types demo\", overlay = true)\n//@variable A value of the \"const string\" type for the `ma` plot's title.\nstring MA_TITLE = \"MA\"\n//@variable A value of the \"input int\" type. Controls the length of the average.\nint lengthInput = input.int(100, \"Length\", minval = 2)\n//@variable A \"series float\" value representing the last `close` that crossed over the `ma`.\nvar float crossValue = na\n//@variable A \"series float\" value representing the moving average of `close`.\nfloat ma = ta.sma(close, lengthInput)\n//@variable A \"series bool\" value that's `true` when the `close` crosses over the `ma`.\nbool crossUp = ta.crossover(close, ma)\n//@variable A \"series color\" value based on whether `close` is above or below its `ma`.\ncolor maColor = close > ma ? color.lime : color.fuchsia\n// Update the `crossValue`.\nif crossUp\n    crossValue := close\nplot(ma, MA_TITLE, maColor)\nplot(crossValue, \"Cross value\", style = plot.style_circles)\nplotchar(crossUp, \"Cross Up\", \"▲\", location.belowbar, size = size.small)"
          ],
          "description": "Pine Script _types_ classify values and determine the functions and operations they’re compatible with. They include:\n\n- The fundamental types: [int](https://www.tradingview.com/pine-script-docs/language/type-system/#int), [float](https://www.tradingview.com/pine-script-docs/language/type-system/#float), [bool](https://www.tradingview.com/pine-script-docs/language/type-system/#bool), [color](https://www.tradingview.com/pine-script-docs/language/type-system/#color), and [string](https://www.tradingview.com/pine-script-docs/language/type-system/#string)\n- The special types: [plot](https://www.tradingview.com/pine-script-docs/language/type-system/#plot-and-hline), [hline](https://www.tradingview.com/pine-script-docs/language/type-system/#plot-and-hline), [line](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), [linefill](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), [box](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), [polyline](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), [label](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), [table](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), [chart.point](https://www.tradingview.com/pine-script-docs/language/type-system/#chart-points), [array](https://www.tradingview.com/pine-script-docs/language/type-system/#collections), [matrix](https://www.tradingview.com/pine-script-docs/language/type-system/#collections), and [map](https://www.tradingview.com/pine-script-docs/language/type-system/#collections)\n- [User-defined types (UDTs)](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)\n- [Enums](https://www.tradingview.com/pine-script-docs/language/type-system/#enum-types)\n- [void](https://www.tradingview.com/pine-script-docs/language/type-system/#void)\n\nFundamental types refer to the underlying nature of a value, e.g., a value of 1 is of the “int” type, 1.0 is of the “float” type, “AAPL” is of the “string” type, etc. Special types and user-defined types utilize _IDs_ that refer to objects of a specific type. For example, a value of the “label” type contains an ID that acts as a _pointer_ referring to a “label” object. The “void” type refers to the output from a function or [method](https://www.tradingview.com/pine-script-docs/language/methods/) that does not return a usable value.\n\nPine Script can automatically convert values from some types into others. The auto-casting rules are: **int → float → bool**. See the [Type casting](https://www.tradingview.com/pine-script-docs/language/type-system/#type-casting) section of this page for more information.\n\nIn most cases, Pine Script can automatically determine a value’s type. However, we can also use type keywords to _explicitly_ specify types for readability and for code that requires explicit definitions (e.g., declaring a variable assigned to [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)).",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/type-system/#int",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#float",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#bool",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#color",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#string",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#plot-and-hline",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#chart-points",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#collections",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#enum-types",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#void",
            "https://www.tradingview.com/pine-script-docs/language/methods/",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#type-casting",
            "https://www.tradingview.com/pine-script-reference/v6/#var_na"
          ]
        },
        {
          "type": "Types",
          "heading": "int",
          "remarks": "Represents whole numbers. Built-ins like `bar_index`, `time`, `timenow`, `dayofmonth`, `strategy.wintrades` return 'int'.",
          "examples": [
            "1\n-1\n750"
          ],
          "description": "Values of the “int” type represent integers, i.e., whole numbers without any fractional quantities.\n\nInteger literals are numeric values written in _decimal_ notation.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_bar_index",
            "https://www.tradingview.com/pine-script-reference/v6/#var_time",
            "https://www.tradingview.com/pine-script-reference/v6/#var_timenow",
            "https://www.tradingview.com/pine-script-reference/v6/#var_dayofmonth",
            "https://www.tradingview.com/pine-script-reference/v6/#var_strategy.wintrades"
          ]
        },
        {
          "type": "Types",
          "heading": "float",
          "remarks": "Represents numbers with potential fractional parts. Internal precision is 1e-16. Built-ins like `close`, `hlcc4`, `volume`, `ta.vwap`, `strategy.position_size` return 'float'.",
          "examples": [
            "3.14159   // Rounded value of Pi (π)\n- 3.0\n6.02e23    // 6.02 * 10^23 (a very large value)\n1.6e-19    // 1.6 * 10^-19 (a very small value)"
          ],
          "description": "Values of the “float” type represent floating-point numbers, i.e., numbers that can contain whole and fractional quantities.\n\nFloating-point literals are numeric values written with a `.` delimiter. They may also contain the symbol `e` or `E` (which means “10 raised to the power of X”, where X is the number after the `e` or `E` symbol).",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_close",
            "https://www.tradingview.com/pine-script-reference/v6/#var_hlcc4",
            "https://www.tradingview.com/pine-script-reference/v6/#var_volume",
            "https://www.tradingview.com/pine-script-reference/v6/#var_ta.vwap",
            "https://www.tradingview.com/pine-script-reference/v6/#var_strategy.position_size"
          ]
        },
        {
          "type": "Types",
          "heading": "bool",
          "remarks": "Represents truth values (`true` or `false`). Cannot be `na`. Built-ins like `barstate.isfirst`, `chart.is_heikinashi`, `session.ismarket`, `timeframe.isdaily` return 'bool'.",
          "examples": [
            "true    // true value\nfalse   // false value"
          ],
          "description": "Values of the “bool” type represent the truth value of a comparison or condition, which scripts can use in [conditional structures](https://www.tradingview.com/pine-script-docs/language/conditional-structures/) and other expressions.\n\nThere are only two literals that represent boolean values: `true` and `false`.\n\nA `bool` variable can never be [na](https://www.tradingview.com/pine-script-reference/v6/#var_na), and any [conditional structure](https://www.tradingview.com/pine-script-docs/language/conditional-structures) that can return `na` will return `false` instead. For example, an [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if) condition returns `bool` values, when the condition is not met and the `else` block is not specified, it will returns `false`.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/conditional-structures/",
            "https://www.tradingview.com/pine-script-reference/v6/#var_na",
            "https://www.tradingview.com/pine-script-reference/v6/#kw_if",
            "https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isfirst",
            "https://www.tradingview.com/pine-script-reference/v6/#var_chart.is_heikinashi",
            "https://www.tradingview.com/pine-script-reference/v6/#var_session.ismarket",
            "https://www.tradingview.com/pine-script-reference/v6/#var_timeframe.isdaily"
          ]
        },
        {
          "type": "Types",
          "heading": "color",
          "remarks": "Represents colors using hexadecimal literals (#RRGGBB or #RRGGBBAA) or built-in constants (e.g., `color.red`). Transparency (alpha) is optional in literals (00-FF) or set via `color.new()` (0-100, 0=opaque).",
          "examples": [
            "#000000      // black color\n#FF0000      // red color\n#00FF00      // green color\n#0000FF      // blue color\n#FFFFFF      // white color\n#808080      // gray color\n#3ff7a0      // some custom color\n#FF000080    // 50% transparent red color\n#FF0000ff    // same as #FF0000, fully opaque red color\n#FF000000    // completely transparent red color",
            "//@version=6\nindicator(\"Shading the chart's background\", overlay = true)\n//@variable A \"const color\" value representing the base for each day's color.\ncolor BASE_COLOR = color.rgb(0, 99, 165)\n//@variable A \"series int\" value that modifies the transparency of the `BASE_COLOR` in `color.new()`.\nint transparency = 50 + int(40 * dayofweek / 7)\n// Color the background using the modified `BASE_COLOR`.\nbgcolor(color.new(BASE_COLOR, transparency))"
          ],
          "description": "Color literals have the following format: `#RRGGBB` or `#RRGGBBAA`. The letter pairs represent _hexadecimal_ values between `00` and `FF` (0 to 255 in decimal) where:\n\n- `RR`, `GG` and `BB` pairs respectively represent the values for the color’s red, green and blue components.\n- `AA` is an optional value for the color’s opacity (or _alpha_ component) where `00` is invisible and `FF` opaque. When the literal does not include an `AA` pair, the script treats it as fully opaque (the same as using `FF`).\n- The hexadecimal letters in the literals can be uppercase or lowercase.\n\nPine Script also has [built-in color constants](https://www.tradingview.com/pine-script-docs/concepts/colors/#constant-colors), including [color.green](https://www.tradingview.com/pine-script-reference/v6/#const_color%7Bdot%7Dgreen), [color.red](https://www.tradingview.com/pine-script-reference/v6/#const_color%7Bdot%7Dred), etc.\n\nWhen using built-in color constants, it is possible to add transparency information to them via the [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new) function.\n\nNote that when specifying red, green or blue components in `color.*()` functions, we use “int” or “float” arguments with values between 0 and 255. When specifying transparency, we use a value between 0 and 100, where 0 means fully opaque and 100 means completely transparent.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/concepts/colors/#constant-colors",
            "https://www.tradingview.com/pine-script-reference/v6/#const_color%7Bdot%7Dgreen",
            "https://www.tradingview.com/pine-script-reference/v6/#const_color%7Bdot%7Dred",
            "https://www.tradingview.com/pine-script-reference/v6/#const_color%7Bdot%7Dorange",
            "https://www.tradingview.com/pine-script-reference/v6/#const_color%7Bdot%7Dblue",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_color.new",
            "https://www.tradingview.com/pine-script-docs/concepts/colors/"
          ]
        },
        {
          "type": "Types",
          "heading": "string",
          "remarks": "Represents sequences of characters, enclosed in single ('') or double (\"\") quotes. Use `\\` to escape quotes within strings. `\\n` creates new lines. Use `+` for concatenation. `str.*()` functions provide formatting and manipulation. Built-ins like `syminfo.tickerid`, `syminfo.currency`, `timeframe.period` return 'string'.",
          "examples": [
            "\"This is a string literal using double quotes.\"\n'This is a string literal using single quotes.'",
            "\"It's an example\"\n'The \"Star\" indicator'",
            "'It\\'s an example'\n\"The \\\"Star\\\" indicator\"",
            "\"This\\nString\\nHas\\nOne\\nWord\\nPer\\nLine\"",
            "\"This is a \" + \"concatenated string.\"",
            "//@version=6\nindicator(\"Formatted string demo\", overlay = true)\n//@variable A \"series string\" value representing the bar's OHLC data.\nstring ohlcString = str.format(\"Open: {0}\\nHigh: {1}\\nLow: {2}\\nClose: {3}\", open, high, low, close)\n// Draw a label containing the `ohlcString`.\nlabel.new(bar_index, high, ohlcString, textcolor = color.white)"
          ],
          "description": "Values of the “string” type represent sequences of letters, numbers, symbols, spaces, and other characters.\n\nString literals in Pine are characters enclosed in single or double quotation marks. Single and double quotation marks are functionally equivalent. A “string” enclosed within double quotation marks can contain any number of single quotation marks and vice versa. Scripts can _escape_ the enclosing delimiter in a “string” using the backslash character ( `\\`).\n\nWe can create “string” values containing the new line escape character ( `\\n`) for displaying multi-line text with `plot*()` and `log.*()` functions and objects of [drawing types](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types).\n\nWe can use the [+] operator to concatenate “string” values.\n\nThe built-ins in the `str.*()` namespace create “string” values using specialized operations.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types",
            "https://www.tradingview.com/pine-script-reference/v6/#op_+",
            "https://www.tradingview.com/pine-script-docs/concepts/text-and-shapes/",
            "https://www.tradingview.com/pine-script-reference/v6/#var_syminfo.tickerid",
            "https://www.tradingview.com/pine-script-reference/v6/#var_syminfo.currency",
            "https://www.tradingview.com/pine-script-reference/v6/#var_timeframe.period"
          ]
        },
        {
          "type": "Types",
          "heading": "plot and hline",
          "remarks": "Special types representing chart plots and horizontal lines, returned by `plot()` and `hline()` functions respectively. Their IDs can be used with `fill()`. No explicit `plot` or `hline` keywords exist for declaration. Plot values can be used as external inputs via `input.source()`.",
          "examples": [
            "//@version=6\nindicator(\"plot fill demo\", overlay = true)\n//@variable A \"series float\" value representing a 10-bar EMA of `close`.\nfloat emaFast = ta.ema(close, 10)\n//@variable A \"series float\" value representing a 20-bar EMA of `close`.\nfloat emaSlow = ta.ema(close, 20)\n//@variable The plot of the `emaFast` value.\nemaFastPlot = plot(emaFast, \"Fast EMA\", color.orange, 3)\n//@variable The plot of the `emaSlow` value.\nemaSlowPlot = plot(emaSlow, \"Slow EMA\", color.gray, 3)\n// Fill the space between the `emaFastPlot` and `emaSlowPlot`.\nfill(emaFastPlot, emaSlowPlot, color.new(color.purple, 50), \"EMA Fill\")"
          ],
          "description": "Pine Script’s [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) and [hline()](https://www.tradingview.com/pine-script-reference/v6/#fun_hline) functions return IDs that respectively reference instances of the “plot” and “hline” types. These types display calculated values and horizontal levels on the chart, and one can assign their IDs to variables for use with the built-in [fill()](https://www.tradingview.com/pine-script-reference/v6/#fun_fill) function.\n\nIt’s important to note that unlike other special types, there is no `plot` or `hline` keyword in Pine to explicitly declare a variable’s type as “plot” or “hline”.\n\nUsers can control where their scripts’ plots display via the variables in the `display.*` namespace and a `plot*()` function’s `force_overlay` parameter. Additionally, one script can use the values from another script’s plots as _external inputs_ via the [input.source()](https://www.tradingview.com/pine-script-reference/v6/#fun_input.source) function.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_plot",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_hline",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_fill",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_input.source",
            "https://www.tradingview.com/pine-script-docs/concepts/inputs/#source-input"
          ]
        },
        {
          "type": "Types",
          "heading": "Drawing types",
          "remarks": "Special types for creating chart drawings: line, linefill, box, polyline, label, table. Each has a corresponding namespace (e.g., `line.*`) with functions like `*.new()` to create instances. These functions return 'series' qualified IDs which act as pointers to the drawing objects.",
          "examples": [],
          "description": "Pine Script drawing types allow scripts to create custom drawings on charts. They include the following: [line](https://www.tradingview.com/pine-script-reference/v6/#type_line), [linefill](https://www.tradingview.com/pine-script-reference/v6/#type_linefill), [box](https://www.tradingview.com/pine-script-reference/v6/#type_box), [polyline](https://www.tradingview.com/pine-script-reference/v6/#type_polyline), [label](https://www.tradingview.com/pine-script-reference/v6/#type_label), and [table](https://www.tradingview.com/pine-script-reference/v6/#type_table).\n\nEach type also has a namespace containing all the built-ins that create and manage drawing instances. For example, the following `*.new()` constructors create new objects of these types in a script: [line.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_line.new), [linefill.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_linefill.new), [box.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_box.new), [polyline.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_polyline.new), [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new), and [table.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_table.new).\n\nEach of these functions returns an _ID_ which is a reference that uniquely identifies a drawing object. IDs are always qualified as “series”, meaning their qualified types are “series line”, “series label”, etc. Drawing IDs act like pointers, as each ID references a specific instance of a drawing in all the functions from that drawing’s namespace.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#type_line",
            "https://www.tradingview.com/pine-script-reference/v6/#type_linefill",
            "https://www.tradingview.com/pine-script-reference/v6/#type_box",
            "https://www.tradingview.com/pine-script-reference/v6/#type_polyline",
            "https://www.tradingview.com/pine-script-reference/v6/#type_label",
            "https://www.tradingview.com/pine-script-reference/v6/#type_table",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_line.new",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_linefill.new",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_box.new",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_polyline.new",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_label.new",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_table.new",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_line.delete"
          ]
        },
        {
          "type": "Types",
          "heading": "Chart points",
          "remarks": "Special type `chart.point` representing chart coordinates (time, index, price). Used to position drawings (lines, boxes, polylines, labels). Created using functions like `chart.point.new()`, `chart.point.now()`, `chart.point.from_index()`, `chart.point.from_time()`, `chart.point.copy()`. The x-coordinate used depends on the drawing's `xloc` property.",
          "examples": [
            "//@version=6\nindicator(\"Chart points demo\", overlay = true)\n//@variable A new `chart.point` at the previous `bar_index` and `high`.\nfirstPoint = chart.point.from_index(bar_index - 1, high[1])\n//@variable A new `chart.point` at the current bar's `low`.\nsecondPoint = chart.point.now(low)\n// Draw a new line connecting coordinates from the `firstPoint` and `secondPoint`.\n// This line uses the `index` fields from the points as x-coordinates.\nline.new(firstPoint, secondPoint, color = color.purple, width = 3)\n// Draw a label at the `firstPoint`. Uses the point's `index` field as its x-coordinate.\nlabel.new(\n     firstPoint, str.tostring(firstPoint.price), color = color.green,\n     style = label.style_label_down, textcolor = color.white\n)\n// Draw a label at the `secondPoint`. Uses the point's `index` field as its x-coordinate.\nlabel.new(\n     secondPoint, str.tostring(secondPoint.price), color = color.red,\n     style = label.style_label_up, textcolor = color.white\n)"
          ],
          "description": "Chart points are special types that represent coordinates on the chart. Scripts use the information from [chart.point](https://www.tradingview.com/pine-script-reference/v6/#type_chart.point) objects to determine the chart locations of [lines](https://www.tradingview.com/pine-script-docs/concepts/lines-and-boxes/#lines), [boxes](https://www.tradingview.com/pine-script-docs/concepts/lines-and-boxes/#boxes), [polylines](https://www.tradingview.com/pine-script-docs/concepts/lines-and-boxes/#polylines), and [labels](https://www.tradingview.com/pine-script-docs/concepts/text-and-shapes/#labels).\n\nObjects of this type contain three _fields_: `time`, `index`, and `price`. Whether a drawing instance uses the `time` or `price` field from a [chart.point](https://www.tradingview.com/pine-script-reference/v6/#type_chart.point) as an x-coordinate depends on the drawing’s `xloc` property.\n\nWe can use any of the following functions to create chart points in a script:\n\n- [chart.point.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_chart.point.new) - Creates a new [chart.point](https://www.tradingview.com/pine-script-reference/v6/#type_chart.point) with a specified `time`, `index`, and `price`.\n- [chart.point.now()](https://www.tradingview.com/pine-script-reference/v6/#fun_chart.point.now) - Creates a new [chart.point](https://www.tradingview.com/pine-script-reference/v6/#type_chart.point) with a specified `price` y-coordinate. The `time` and `index` fields contain the [time](https://www.tradingview.com/pine-script-reference/v6/#var_time) and [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index) of the bar the function executes on.\n- [chart.point_from_index()](https://www.tradingview.com/pine-script-reference/v6/#fun_chart.point.from_index) - Creates a new [chart.point](https://www.tradingview.com/pine-script-reference/v6/#type_chart.point) with an `index` x-coordinate and `price` y-coordinate. The `time` field is [na](https://www.tradingview.com/pine-script-reference/v6/#var_na).\n- [chart.point.from_time()](https://www.tradingview.com/pine-script-reference/v6/#fun_chart.point.from_time) - Creates a new [chart.point](https://www.tradingview.com/pine-script-reference/v6/#type_chart.point) with a `time` x-coordinate and `price` y-coordinate. The `index` field is [na](https://www.tradingview.com/pine-script-reference/v6/#var_na).\n- [chart.point.copy()](https://www.tradingview.com/pine-script-reference/v6/#fun_chart.point.copy) - Creates a copy of an existing [chart.point](https://www.tradingview.com/pine-script-reference/v6/#type_chart.point).",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#type_chart.point",
            "https://www.tradingview.com/pine-script-docs/concepts/lines-and-boxes/#lines",
            "https://www.tradingview.com/pine-script-docs/concepts/lines-and-boxes/#boxes",
            "https://www.tradingview.com/pine-script-docs/concepts/lines-and-boxes/#polylines",
            "https://www.tradingview.com/pine-script-docs/concepts/text-and-shapes/#labels",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_chart.point.new",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_chart.point.now",
            "https://www.tradingview.com/pine-script-reference/v6/#var_time",
            "https://www.tradingview.com/pine-script-reference/v6/#var_bar_index",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_chart.point.from_index",
            "https://www.tradingview.com/pine-script-reference/v6/#var_na",
            "https://www.tradingview.com/pine-script-reference/v6/#var_xloc.bar_time",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_chart.point.from_time",
            "https://www.tradingview.com/pine-script-reference/v6/#var_xloc.bar_index",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_chart.point.copy",
            "https://www.tradingview.com/pine-script-reference/v6/#var_high",
            "https://www.tradingview.com/pine-script-reference/v6/#var_low"
          ]
        },
        {
          "type": "Types",
          "heading": "Collections",
          "remarks": "Collections (arrays, matrices, maps) use reference IDs. Their element types are specified using type templates (e.g., `array<int>`, `matrix<float>`, `map<string, color>`). The generic `*.new<type>()` syntax is preferred over type-specific versions like `array.new_int()`.",
          "examples": [
            "a1 = array.new<int>(1, 10)\narray<int> a2 = array.new<int>(1, 10)\na3 = array.from(10)\narray<int> a4 = array.from(10)"
          ],
          "description": "Collections in Pine Script ( [arrays](https://www.tradingview.com/pine-script-docs/language/arrays/), [matrices](https://www.tradingview.com/pine-script-docs/language/matrices/), and [maps](https://www.tradingview.com/pine-script-docs/language/maps/)) utilize reference IDs, much like other special types (e.g., labels). The type of the ID defines the type of _elements_ the collection will contain. In Pine, we specify array, matrix, and map types by appending a [type template](https://www.tradingview.com/pine-script-docs/language/type-system/#type-templates) to the [array](https://www.tradingview.com/pine-script-reference/v6/#type_array), [matrix](https://www.tradingview.com/pine-script-reference/v6/#type_matrix), or [map](https://www.tradingview.com/pine-script-reference/v6/#type_map) keywords:\n\n- `array<int>` defines an array containing “int” elements.\n- `array<label>` defines an array containing “label” IDs.\n- `array<UDT>` defines an array containing IDs referencing objects of a [user-defined type (UDT)](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types).\n- `matrix<float>` defines a matrix containing “float” elements.\n- `matrix<UDT>` defines a matrix containing IDs referencing objects of a [user-defined type (UDT)](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types).\n- `map<string, float>` defines a map containing “string” keys and “float” values.\n- `map<int, UDT>` defines a map containing “int” keys and IDs of [user-defined type (UDT)](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types) instances as values.\n\nNote that:\n\n- The `int[]` syntax can also specify an array of “int” elements, but its use is discouraged. No equivalent exists to specify the types of matrices or maps in that way.\n- Type-specific built-ins exist for arrays, such as [array.new_int()](https://www.tradingview.com/pine-script-reference/v6/#fun_array%7Bdot%7Dnew_int), but the more generic [array.new<type>](https://www.tradingview.com/pine-script-reference/v6/#type_array) form is preferred, which would be `array.new<int>()` to create an array of “int” elements.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/arrays/",
            "https://www.tradingview.com/pine-script-docs/language/matrices/",
            "https://www.tradingview.com/pine-script-docs/language/maps/",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#type-templates",
            "https://www.tradingview.com/pine-script-reference/v6/#type_array",
            "https://www.tradingview.com/pine-script-reference/v6/#type_matrix",
            "https://www.tradingview.com/pine-script-reference/v6/#type_map",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_array%7Bdot%7Dnew_int"
          ]
        },
        {
          "type": "Types",
          "heading": "User-defined types",
          "remarks": "User-defined types (UDTs) are custom composite types created using the `type` keyword. They contain named fields of various types. Fields can have default values (defaulting to `na`). UDTs support recursion (fields referencing the same UDT). Objects are created using the UDT's `new()` method and copied with `copy()`. Can be exported from libraries using `export`.",
          "examples": [
            "    //@type           A user-defined type containing pivot information.\n    //@field pivotTime  Contains time information about the pivot.\n    //@field priceLevel Contains price information about the pivot.\n    type pivotPoint\n        int   pivotTime\n        float priceLevel",
            "    //@type           A user-defined type containing pivot information.\n    //@field pivotTime  Contains time information about the pivot.\n    //@field priceLevel Contains price information about the pivot.\n    //@field nextPivot  A `pivotPoint` instance containing additional pivot information.\n    type pivotPoint\n        int        pivotTime\n        float      priceLevel\n        pivotPoint nextPivot"
          ],
          "description": "The [type](https://www.tradingview.com/pine-script-reference/v6/#kw_type) keyword allows the creation of _user-defined types_ (UDTs) from which scripts can create [objects](https://www.tradingview.com/pine-script-docs/language/objects/). UDTs are composite types; they contain an arbitrary number of _fields_ that can be of any type, including other user-defined types.\n\nThe syntax to declare a user-defined type is:\n\n```\n[export ]type <UDT_identifier>\n    <field_type> <field_name>[ = <value>]\n    ...\n```\n\nwhere:\n\n- [export](https://www.tradingview.com/pine-script-reference/v6/#kw_export) is the keyword that a [library](https://www.tradingview.com/pine-script-reference/v6/#fun_library) script uses to export the user-defined type.\n- `<UDT_identifier>` is the name of the user-defined type.\n- `<field_type>` is the type of the field.\n- `<field_name>` is the name of the field.\n- `<value>` is an optional default value for the field. If not provided, the default is [na](https://www.tradingview.com/pine-script-reference/v6/#var_na).\n\nUser-defined types support _type recursion_, i.e., the fields of a UDT can reference objects of the same UDT.\n\nScripts can use two built-in methods to create and copy UDTs: `new()` and `copy()`.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#kw_type",
            "https://www.tradingview.com/pine-script-docs/language/objects/",
            "https://www.tradingview.com/pine-script-reference/v6/#kw_export",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_library",
            "https://www.tradingview.com/pine-script-docs/concepts/libraries/#user-defined-types-and-objects",
            "https://www.tradingview.com/pine-script-reference/v6/#var_na",
            "https://www.tradingview.com/pine-script-reference/v6/#op_%5B%5D"
          ]
        },
        {
          "type": "Types",
          "heading": "Enum types",
          "remarks": "Enumerated types created using the `enum` keyword. Define a set of named members (fields) with optional string titles. Used for controlled value sets and dropdown inputs via `input.enum()`. Enum members are 'simple' qualified. Can be exported from libraries.",
          "examples": [
            "//@enum       An enumeration of named values for moving average selection.\n//@field sma  Selects a Simple Moving Average.\n//@field ema  Selects an Exponential Moving Average.\n//@field wma  Selects a Weighted Moving Average.\n//@field hma  Selects a Hull Moving Average.\nenum maChoice\n    sma  = \"Simple Moving Average\"\n    ema  = \"Exponential Moving Average\"\n    wma  = \"Weighted Moving Average\"\n    hma  = \"Hull Moving Average\"",
            "//@version=6\nindicator(\"Enum types demo\", overlay = true)\n//@enum       An enumeration of named values for moving average selection.\n//@field sma  Selects a Simple Moving Average.\n//@field ema  Selects an Exponential Moving Average.\n//@field wma  Selects a Weighted Moving Average.\n//@field hma  Selects a Hull Moving Average.\nenum maChoice\n    sma  = \"Simple Moving Average\"\n    ema  = \"Exponential Moving Average\"\n    wma  = \"Weighted Moving Average\"\n    hma  = \"Hull Moving Average\"\n//@variable The `maChoice` member representing a selected moving average name.\nmaChoice maInput = input.enum(maChoice.sma, \"Moving average type\")\n//@variable The length of the moving average.\nint lengthInput = input.int(20, \"Length\", 1, 4999)\n//@variable The moving average selected by the `maInput`.\nfloat selectedMA = switch maInput\n    maChoice.sma => ta.sma(close, lengthInput)\n    maChoice.ema => ta.ema(close, lengthInput)\n    maChoice.wma => ta.wma(close, lengthInput)\n    maChoice.hma => ta.hma(close, lengthInput)\n// Plot the `selectedMA`.\nplot(selectedMA, \"Selected moving average\", color.teal, 3)"
          ],
          "description": "The [enum](https://www.tradingview.com/pine-script-reference/v6/#kw_enum) keyword allows the creation of an _enum_, otherwise known as an _enumeration_, _enumerated type_, or _enum type_. An enum is a unique type construct containing distinct, named fields representing _members_ (i.e., possible values) of the type. Enums allow programmers to control the values accepted by variables, conditional expressions, and [collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections), and they facilitate convenient dropdown [input](https://www.tradingview.com/pine-script-docs/concepts/inputs/#enum-input) creation with the [input.enum()](https://www.tradingview.com/pine-script-reference/v6/#fun_input.enum) function.\n\nThe syntax to declare an enum is as follows:\n\n```\n[export ]enum <enumName>\n    <field_1>[ = <title_1>]\n    <field_2>[ = <title_2>]\n    ...\n    <field_N>[ = <title_N>]\n```\n\nwhere:\n\n- [export](https://www.tradingview.com/pine-script-reference/v6/#kw_export) is the optional keyword allowing a [library](https://www.tradingview.com/pine-script-reference/v6/#fun_library) to export the enum.\n- `<enumName>` is the name of the enum type.\n- `<field_*>` is the name of an enum field (member).\n- `<title_*>` is an optional “const string” title for the field, used in inputs and by `str.tostring()`. Defaults to the field name.\n\nNote that:\n\n- All the enum’s possible values are available upon the _first_ script execution and do not change across subsequent executions. Hence, they automatically adopt the [simple](https://www.tradingview.com/pine-script-docs/language/type-system/#simple) qualifier.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#kw_enum",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#collections",
            "https://www.tradingview.com/pine-script-docs/concepts/inputs/#enum-input",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_input.enum",
            "https://www.tradingview.com/pine-script-reference/v6/#kw_export",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_library",
            "https://www.tradingview.com/pine-script-docs/concepts/libraries/#enum-types",
            "https://www.tradingview.com/pine-script-docs/language/variable-declarations/",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#type-templates",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_str.tostring",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#simple",
            "https://www.tradingview.com/pine-script-reference/v6/#kw_switch",
            "https://www.tradingview.com/pine-script-docs/language/enums/",
            "https://www.tradingview.com/pine-script-docs/concepts/inputs/"
          ]
        },
        {
          "type": "Types",
          "heading": "void",
          "remarks": "Represents the return type of functions that perform actions but return no usable value (e.g., `alert()`). Void results cannot be used in expressions or assigned to variables. No `void` keyword exists for declaration.",
          "examples": [],
          "description": "There is a “void” type in Pine Script. Functions having only side-effects and returning no usable result return the “void” type. An example of such a function is [alert()](https://www.tradingview.com/pine-script-reference/v6/#fun_alert); it does something (triggers an alert event), but it returns no usable value.\n\nScripts cannot use “void” results in expressions or assign them to variables. No `void` keyword exists in Pine Script since one cannot declare a variable of the “void” type.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_alert"
          ]
        },
        {
          "type": "Constants",
          "heading": "`na` value",
          "remarks": "`na` represents an undefined or 'not available' value. It can be cast to most types, but explicit type declaration or casting (e.g., `float myVar = na` or `myVar = float(na)`) is needed when assigning `na` directly if the type cannot be inferred. Use `na(value)` to check for `na`, not `== na`. Use `nz(value, default)` to handle potential `na` values in calculations.",
          "examples": [
            "// Compilation error!\nmyVar = na",
            "float myVar = na",
            "myVar = float(na)",
            "//@variable Is 0 if the `myVar` is `na`, `close` otherwise.\nfloat myClose = na(myVar) ? 0 : close",
            "//@variable Returns the `close` value. The script cannot compare the equality of `na` values, as they're undefined.\nfloat myClose = myVar == na ? 0 : close",
            "//@variable Is `true` when the `close` exceeds the last bar's `close` (or the current `open` if the value is `na`).\nbool risingClose = close > nz(close[1], open)",
            "//@version=6\nindicator(\"na protection demo\", overlay = true)\n//@variable The result of calculating the all-time high price with an initial value of `na`.\nvar float allTimeHigh = na\n// Reassign the value of the `allTimeHigh`.\n// Returns `na` on all bars because `math.max()` can't compare the `high` to an undefined value.\nallTimeHigh := math.max(allTimeHigh, high)\nplot(allTimeHigh) // Plots `na` on all bars.",
            "//@version=6\nindicator(\"na protection demo\", overlay = true)\n//@variable The result of calculating the all-time high price with an initial value of `na`.\nvar float allTimeHigh = na\n// Reassign the value of the `allTimeHigh`.\n// We've used `nz()` to prevent the initial `na` value from persisting throughout the calculation.\nallTimeHigh := math.max(nz(allTimeHigh), high)\nplot(allTimeHigh)"
          ],
          "description": "There is a special value in Pine Script called [na](https://www.tradingview.com/pine-script-reference/v6/#var_na), which is an acronym for _not available_. We use [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) to represent an undefined value from a variable or expression. It is similar to `null` in Java and `None` in Python.\n\nScripts can automatically cast [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) values to almost any type. However, in some cases, the compiler cannot infer the type associated with an [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) value because more than one type-casting rule may apply. To resolve such errors, we must explicitly declare the type associated with the variable or explicitly cast the `na` value using a type function (e.g., `float(na)`).\n\nTo test if the value from a variable or expression is [na](https://www.tradingview.com/pine-script-reference/v6/#var_na), we call the [na()](https://www.tradingview.com/pine-script-reference/v6/#fun_na) function, which returns `true` if the value is undefined. Do not use the `==` comparison operator to test for [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) values.\n\nBest coding practices often involve handling [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) values to prevent undefined values in calculations, often using the [nz()](https://www.tradingview.com/pine-script-reference/v6/#fun_nz) function to provide a default value if a variable is `na`.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_na",
            "https://www.tradingview.com/pine-script-reference/v6/#type_float",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_float",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_na",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_nz",
            "https://www.tradingview.com/pine-script-reference/v6/#var_close",
            "https://www.tradingview.com/pine-script-reference/v6/#var_open",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_math.max",
            "https://www.tradingview.com/pine-script-reference/v6/#var_high"
          ]
        },
        {
          "type": "Types",
          "heading": "Type templates",
          "remarks": "Syntax used to specify the element types within collections (arrays, matrices, maps). Uses angle brackets `<>`. Arrays/matrices take one type (e.g., `<int>`, `<label>`). Maps take two types: key and value (e.g., `<string, float>`). Supported types include fundamental, some special types (drawings, chart.point), UDTs, and enums. Map keys can only be fundamental types or enums. Used in variable declarations and collection creation (e.g., `array.new<int>()`).",
          "examples": [
            "//@version=6\nindicator(\"Type templates demo\")\n//@variable A variable initially assigned to `na` that accepts arrays of \"int\" values.\narray<int> intArray = na\n//@variable An empty matrix that holds \"float\" values.\nfloatMatrix = matrix.new<float>()\n//@variable An empty map that holds \"string\" keys and \"color\" values.\nstringColorMap = map.new<string, color>()"
          ],
          "description": "Type templates specify the data types that collections ( [arrays](https://www.tradingview.com/pine-script-docs/language/arrays/), [matrices](https://www.tradingview.com/pine-script-docs/language/matrices/), and [maps](https://www.tradingview.com/pine-script-docs/language/maps/)) can contain.\n\nTemplates for [arrays](https://www.tradingview.com/pine-script-docs/language/arrays/) and [matrices](https://www.tradingview.com/pine-script-docs/language/matrices/) consist of a single type identifier surrounded by angle brackets, e.g., `<int>`, `<label>`, and `<PivotPoint>` (where `PivotPoint` is a [user-defined type (UDT)](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)).\n\nTemplates for [maps](https://www.tradingview.com/pine-script-docs/language/maps/) consist of two type identifiers enclosed in angle brackets, where the first specifies the type of _keys_ in each key-value pair, and the second specifies the _value_ type. For example, `<string, float>` is a type template for a map that holds `string` keys and `float` values.\n\nUsers can construct type templates from:\n\n- Fundamental types: [int](https://www.tradingview.com/pine-script-docs/language/type-system/#int), [float](https://www.tradingview.com/pine-script-docs/language/type-system/#float), [bool](https://www.tradingview.com/pine-script-docs/language/type-system/#bool), [color](https://www.tradingview.com/pine-script-docs/language/type-system/#color), and [string](https://www.tradingview.com/pine-script-docs/language/type-system/#string)\n- The following special types: [line](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), [linefill](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), [box](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), [polyline](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), [label](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), [table](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), and [chart.point](https://www.tradingview.com/pine-script-docs/language/type-system/#chart-points)\n- [User-defined types (UDTs)](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)\n- [Enum types](https://www.tradingview.com/pine-script-docs/language/type-system/#enum-types)\n\nNote that:\n\n- [Maps](https://www.tradingview.com/pine-script-docs/language/maps/) can use any of these types as _values_, but they can only accept fundamental types or [enum types](https://www.tradingview.com/pine-script-docs/language/type-system/#enum-types) as _keys_.\n\nScripts use type templates to declare variables that reference collections, and when creating new collection instances.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/arrays/",
            "https://www.tradingview.com/pine-script-docs/language/matrices/",
            "https://www.tradingview.com/pine-script-docs/language/maps/",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#int",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#float",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#bool",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#color",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#string",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#chart-points",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#enum-types"
          ]
        },
        {
          "type": "Functions",
          "heading": "Type casting",
          "remarks": "Pine automatically casts 'int' to 'float'. For other conversions, explicit casting functions like `int()`, `float()`, `bool()`, `color()`, `string()`, `label()`, etc., must be used. This is required when a function expects a specific type (e.g., `int` length for `ta.sma()`) but receives another compatible type (e.g., `float`). Also used to specify the type of a variable initialized with `na`.",
          "examples": [
            "//@version=6\nindicator(\"Explicit casting demo\", overlay = true)\n//@variable The length of the SMA calculation. Qualified as \"const float\".\nfloat LENGTH = 10.0\nfloat sma = ta.sma(close, LENGTH) // Compilation error. The `length` parameter requires an \"int\" value.\nplot(sma)",
            "//@version=6\nindicator(\"explicit casting demo\")\n//@variable The length of the SMA calculation. Qualified as \"const float\".\nfloat LENGTH = 10.0\nfloat sma = ta.sma(close, int(LENGTH)) // Compiles successfully since we've converted the `LENGTH` to \"int\".\nplot(sma)",
            "// Explicitly specify that the variable references \"label\" objects:\nlabel myLabel = na\n// Explicitly cast the `na` value to the \"label\" type:\nmyLabel = label(na)"
          ],
          "description": "Pine Script includes an automatic type-casting mechanism that _casts_ (converts) **“int”** values to **“float”** when necessary. Variables or expressions requiring “float” values can also use “int” values because any integer can be represented as a floating point number with its fractional part equal to 0.\n\nIt’s sometimes necessary to cast one type to another when auto-casting rules do not suffice. For such cases, the following type-casting functions are available: [int()](https://www.tradingview.com/pine-script-reference/v6/#fun_int), [float()](https://www.tradingview.com/pine-script-reference/v6/#fun_float), [bool()](https://www.tradingview.com/pine-script-reference/v6/#fun_bool), [color()](https://www.tradingview.com/pine-script-reference/v6/#fun_color), [string()](https://www.tradingview.com/pine-script-reference/v6/#fun_string), [line()](https://www.tradingview.com/pine-script-reference/v6/#fun_line), [linefill()](https://www.tradingview.com/pine-script-reference/v6/#fun_linefill), [label()](https://www.tradingview.com/pine-script-reference/v6/#fun_label), [box()](https://www.tradingview.com/pine-script-reference/v6/#fun_box), and [table()](https://www.tradingview.com/pine-script-reference/v6/#fun_table).\n\nExplicit type casting is also handy when declaring variables assigned to [na](https://www.tradingview.com/pine-script-reference/v6/#var_na).",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_int",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_float",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_bool",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_color",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_string",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_line",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_linefill",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_label",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_box",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_table",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma",
            "https://www.tradingview.com/pine-script-reference/v6/#var_na",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#na-value"
          ]
        },
        {
          "type": "Types",
          "heading": "Tuples",
          "remarks": "A comma-separated set of expressions in brackets `[]`, used for returning multiple values from functions/methods/blocks. Declared using `[var1, var2] = ...` syntax to capture multiple return values. Can contain mixed types. `if`/`switch` blocks can return tuples, ternaries cannot. All elements adopt the strongest qualifier ('series' dominates).",
          "examples": [
            "//@function Calculates the sum and product of two values.\ncalcSumAndProduct(float a, float b) =>\n    //@variable The sum of `a` and `b`.\n    float sum = a + b\n    //@variable The product of `a` and `b`.\n    float product = a * b\n    // Return a tuple containing the `sum` and `product`.\n    [sum, product]",
            "// Declare a tuple containing the sum and product of the `high` and `low`, respectively.\n[hlSum, hlProduct] = calcSumAndProduct(high, low)",
            "//@function Returns information about the current chart.\nchartInfo() =>\n    //@variable The first visible bar's UNIX time value.\n    int firstVisibleTime = chart.left_visible_bar_time\n    //@variable The `close` value at the `firstVisibleTime`.\n    float firstVisibleClose = ta.valuewhen(ta.cross(time, firstVisibleTime), close, 0)\n    //@variable Is `true` when using a standard chart type, `false` otherwise.\n    bool isStandard = chart.is_standard\n    //@variable The foreground color of the chart.\n    color fgColor = chart.fg_color\n    //@variable The ticker ID of the current chart.\n    string symbol = syminfo.tickerid\n    // Return a tuple containing the values.\n    [firstVisibleTime, firstVisibleClose, isStandard, fgColor, symbol]",
            "//@function Returns a tuple of OHLC values, rounded to the nearest tick.\nroundedOHLC() =>\n    [math.round_to_mintick(open), math.round_to_mintick(high), math.round_to_mintick(low), math.round_to_mintick(close)]\n[op, hi, lo, cl] = request.security(syminfo.tickerid, \"D\", roundedOHLC())",
            "[op, hi, lo, cl] = request.security(\n     syminfo.tickerid, \"D\",\n     [math.round_to_mintick(open), math.round_to_mintick(high), math.round_to_mintick(low), math.round_to_mintick(close)]\n)",
            "[v1, v2] = if close > open\n    [high, close]\nelse\n    [close, low]",
            "[v1, v2] = switch\nclose > open => [high, close]\n=>             [close, low]",
            "// Not allowed.\n[v1, v2] = close > open ? [high, close] : [close, low]",
            "//@version=6\nindicator(\"Qualified types in tuples demo\")\ngetParameters(float source, simple int length) =>\n    // The second item in the tuple becomes a \"series\" if `source` is a \"series\"\n    // because all returned tuple elements adopt the strongest qualifier.\n    [source, length]\n// Although the `length` argument is a \"const int\", the `len` variable is a \"series\" because `src` is a \"series\".\n[src, len] = getParameters(close, 20)\n// Causes a compilation error because `ta.ema()` requires a \"simple int\" `length` argument.\nplot(ta.ema(src, len))"
          ],
          "description": "A _tuple_ is a comma-separated set of expressions enclosed in brackets `[]`. When a function, [method](https://www.tradingview.com/pine-script-docs/language/methods/), or other local block returns more than one value, scripts return those values in the form of a tuple.\n\nWhen calling a function that returns a tuple, use a _tuple_ _declaration_ `[var1, var2] = functionCall()` to assign the returned values to multiple variables simultaneously. The types of the variables in the tuple declaration are inferred automatically and cannot be explicitly declared.\n\nTuples can contain values of _multiple types_. Local blocks of [conditional structures](https://www.tradingview.com/pine-script-docs/language/conditional-structures/) ([if](https://www.tradingview.com/pine-script-reference/v6/#kw_if), [switch](https://www.tradingview.com/pine-script-reference/v6/#kw_switch)) can return tuples, but ternaries cannot.\n\nAll items within a tuple returned from a function adopt the strongest qualifier among the elements. If any element is 'series', all become 'series'.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/methods/",
            "https://www.tradingview.com/pine-script-docs/language/user-defined-functions/",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_request.security",
            "https://www.tradingview.com/pine-script-reference/v6/#var_syminfo.mintick",
            "https://www.tradingview.com/pine-script-docs/language/conditional-structures/",
            "https://www.tradingview.com/pine-script-reference/v6/#kw_if",
            "https://www.tradingview.com/pine-script-reference/v6/#kw_switch"
          ]
        },
        {
          "type": "Types",
          "heading": "Type system",
          "remarks": "The Pine compiler distinguishes between different forms of the same type, e.g., literal bool vs. input bool.",
          "examples": [],
          "description": "Pine has 9 fundamental data types: int, float, bool, color, string, line, label, plot, hline. These types exist in 5 forms: literal, const, input, simple, and series. There is also an array type, a void type, a na (not available) value, and a compound tuple type.",
          "related_links": []
        },
        {
          "type": "Types",
          "heading": "Type forms",
          "remarks": "",
          "examples": [],
          "description": "Describes the different forms that Pine types can take: literal, const, input, simple, and series.",
          "related_links": []
        },
        {
          "type": "Types",
          "heading": "Literal",
          "remarks": "",
          "examples": [
            "3.14",
            "6.02E-23",
            "3e8",
            "42",
            "true",
            "false",
            "\"A text literal\"",
            "#FF55C6"
          ],
          "description": "A literal is a special notation for representing a fixed value in Pine. Literal expressions are always of one of the 5 following types: literal float, literal int, literal bool, literal string, literal color.",
          "related_links": []
        },
        {
          "type": "Constants",
          "heading": "Const",
          "remarks": "A variable initialized with a literal expression is const. An expression involving only const values results in a const value.",
          "examples": [
            "c1 = 0",
            "c2 = c1 + 1"
          ],
          "description": "Values of the form const are ones that do not change during script execution and are known or can be calculated at compile time.",
          "related_links": []
        },
        {
          "type": "Types",
          "heading": "Input",
          "remarks": "The variable `p` in the example has the type _input integer_.",
          "examples": [
            "p = input(10, title=\"Period\")"
          ],
          "description": "Values of the form input are ones that do not change during script execution, are unknown at compile time, and originate from an input() function.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v4/#fun_input"
          ]
        },
        {
          "type": "Types",
          "heading": "Simple",
          "remarks": "The built-in variable syminfo.mintick is a _simple float_. The word 'simple' is often omitted (e.g., 'float' instead of 'simple float').",
          "examples": [],
          "description": "Values of the form simple are ones that do not change during script execution and are unknown at compile time. They typically come from the main chart’s symbol information.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v4/#var_syminfo%7Bdot%7Dmintick"
          ]
        },
        {
          "type": "Types",
          "heading": "Series",
          "remarks": "Series is the most common form. Built-in series variables include open, high, low, close, volume, time. Series can contain 'na' values. Only the last value (current bar) is writable.",
          "examples": [
            "a = open + close",
            "b = high / 2",
            "c = close[1]"
          ],
          "description": "Values of the form series change during script execution, store a sequence of historical values associated with bars, and can be accessed using the [] operator.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v4/language/operators/#history-reference-operator-"
          ]
        },
        {
          "type": "Types",
          "heading": "Fundamental types",
          "remarks": "",
          "examples": [],
          "description": "Overview of the 9 fundamental data types in Pine.",
          "related_links": []
        },
        {
          "type": "Types",
          "heading": "int",
          "remarks": "There are 5 forms: literal int, const int, input int, int, series int.",
          "examples": [
            "1",
            "750",
            "94572",
            "100"
          ],
          "description": "Integer type. Literals must be written in decimal notation.",
          "related_links": []
        },
        {
          "type": "Types",
          "heading": "float",
          "remarks": "There are 5 forms: literal float, const float, input float, float, series float. Internal precision is 1e-10.",
          "examples": [
            "3.14159",
            "6.02e23",
            "1.6e-19",
            "3.0"
          ],
          "description": "Floating-point type. Literals contain a delimiter (.) and may contain 'e' for scientific notation.",
          "related_links": []
        },
        {
          "type": "Types",
          "heading": "bool",
          "remarks": "There are 5 forms: literal bool, const bool, input bool, bool, series bool.",
          "examples": [
            "true",
            "false"
          ],
          "description": "Boolean type. Represents true or false values.",
          "related_links": []
        },
        {
          "type": "Types",
          "heading": "color",
          "remarks": "There are 5 forms: literal color, const color, input color, color, series color. Built-in color variables (e.g., color.red) exist. Transparency can be changed using color.new(). An input color type can result from expressions involving other input types.",
          "examples": [
            "#000000",
            "#FF0000",
            "#00FF00",
            "#0000FF",
            "#FFFFFF",
            "#808080",
            "#3ff7a0",
            "#FF000080",
            "#FF0000FF",
            "#FF000000"
          ],
          "description": "Color type. Literals are represented in hexadecimal format #RRGGBB or #RRGGBBAA.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v4/#fun_input",
            "https://www.tradingview.com/pine-script-reference/v4/#fun_color%7Bdot%7Dnew"
          ]
        },
        {
          "type": "Types",
          "heading": "string",
          "remarks": "There are 5 forms: literal string, const string, input string, string, series string. Use backslash to escape delimiter characters within the string.",
          "examples": [
            "\"This is a double quoted string literal\"",
            "'This is a single quoted string literal'",
            "\"It's an example\"",
            "'The \"Star\" indicator'",
            "'It\\'s an example'",
            "\"The \\\"Star\\\" indicator\""
          ],
          "description": "String type. Represents text literals enclosed in single or double quotation marks.",
          "related_links": []
        },
        {
          "type": "Types",
          "heading": "line and label",
          "remarks": "Their type is series line and series label, respectively. There is only one form (series) for these types.",
          "examples": [],
          "description": "Drawing object types introduced in Pine v4, created with line.new() and label.new() functions.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v4/#fun_line%7Bdot%7Dnew",
            "https://www.tradingview.com/pine-script-reference/v4/#fun_label%7Bdot%7Dnew"
          ]
        },
        {
          "type": "Annotations",
          "heading": "plot and hline",
          "remarks": "plot() returns a 'plot' type object (line/diagram). hline() returns an 'hline' type object (horizontal line). These objects can be passed to the fill() function.",
          "examples": [],
          "description": "Types representing objects created on the chart by annotation functions like plot() and hline().",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v4/#fun_fill"
          ]
        },
        {
          "type": "Types",
          "heading": "array",
          "remarks": "Array element types are limited to int, float, bool, and color.",
          "examples": [
            "int[]",
            "float[]",
            "bool[]",
            "color[]"
          ],
          "description": "Arrays in Pine are identified by an array id. The type reflects the type of the array's elements.",
          "related_links": []
        },
        {
          "type": "Types",
          "heading": "void",
          "remarks": "Functions like strategy.entry() and plotshape() return void. A void result cannot be used in expressions or assigned to variables.",
          "examples": [],
          "description": "A type representing the absence of a return value, typically for functions that produce side effects.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v4/#fun_strategy%7Bdot%7Dentry",
            "https://www.tradingview.com/pine-script-reference/v4/#fun_plotshape"
          ]
        },
        {
          "type": "Keywords",
          "heading": "na value",
          "remarks": "Can be automatically cast to most types, but sometimes requires explicit casting (e.g., float(na)). Use the na() function to test for na, not the == operator.",
          "examples": [
            "float myVar = na",
            "myVar = float(na)",
            "myClose = na(myVar) ? 0 : close"
          ],
          "description": "A special built-in variable representing a 'not available' value, similar to null or None.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v4/#fun_na"
          ]
        },
        {
          "type": "Types",
          "heading": "Tuples",
          "remarks": "Tuple elements can be of any type. Special syntax [var1, var2] = functionCall() is used for assignment.",
          "examples": [
            "calcSumAndMul(a, b) =>\n    sum = a + b\n    mul = a * b\n    [sum, mul]",
            "[s, m] = calcSumAndMul(high, low)"
          ],
          "description": "An immutable sequence of values used when a function needs to return multiple results.",
          "related_links": []
        },
        {
          "type": "Types",
          "heading": "Type casting",
          "remarks": "An image illustrating automatic casting rules is provided in the source document. Explicit casting is needed when a function expects a specific type not covered by automatic rules.",
          "examples": [
            "//@version=4\nstudy(\"My Script\")\nlen = 10.0\ns = sma(close, int(len))\nplot(s)"
          ],
          "description": "Pine Script has automatic type casting rules. Explicit type casting functions (int(), float(), string(), bool(), color(), line(), label()) are available for cases where automatic casting doesn't apply.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v4/#fun_int",
            "https://www.tradingview.com/pine-script-reference/v4/#fun_float",
            "https://www.tradingview.com/pine-script-reference/v4/#fun_string",
            "https://www.tradingview.com/pine-script-reference/v4/#fun_bool",
            "https://www.tradingview.com/pine-script-reference/v4/#fun_color",
            "https://www.tradingview.com/pine-script-reference/v4/#fun_line",
            "https://www.tradingview.com/pine-script-reference/v4/#fun_label"
          ]
        },
        {
          "type": "Type",
          "heading": "const",
          "remarks": "The `const` keyword allows the declaration of variables and parameters with constant _value assignments_, forbidding reassignment (`=`) and compound assignment (`+=`, `-=`, etc.) operations. However, declaring a variable with `const` forces it to maintain a constant reference, but doesn't necessarily define the nature of the assigned value (e.g., it could reference a 'series' ID). The Style guide recommends uppercase SNAKE_CASE for 'const' variables. The `var` keyword can be used for 'const' variables initialized only on the first bar.",
          "examples": [
            "//@version=5\n// The following global variables are all of the \"const string\" qualified type:\n//@variable The title of the indicator.\nINDICATOR_TITLE = \"const demo\"\n//@variable The title of the first plot.\nvar PLOT1_TITLE = \"High\"\n//@variable The title of the second plot.\nconst string PLOT2_TITLE = \"Low\"\n//@variable The title of the third plot.\nPLOT3_TITLE = \"Midpoint between \" + PLOT1_TITLE + \" and \" + PLOT2_TITLE\nindicator(INDICATOR_TITLE, overlay = true)\nplot(high, PLOT1_TITLE)\nplot(low, PLOT2_TITLE)\nplot(hl2, PLOT3_TITLE)",
            "//@version=5\n//@variable The title in the `indicator()` call.\nvar NAME = \"My indicator for \" + syminfo.ticker\nindicator(NAME, \"\", true) // Causes an error because `NAME` is qualified as a \"simple string\".\nplot(close)",
            "//@version=5\nindicator(\"Cannot reassign const demo\")\n//@variable A \"float\" variable declared as `const`, preventing reassignment.\nconst float myVar = 0.0\nmyVar += 1.0 // Causes an error. Reassignment and compound assignments are not allowed on `const` variables.\nplot(myVar)",
            "//@version=5\nindicator(\"Constant reference to 'series' ID demo\")\n//@variable A `label` variable declared as `const`, preventing reassignment.\n//         Although the reference is constant, the ID of the `label` is a \"series\" value.\nconst label myVar = label.new(bar_index, close)"
          ],
          "description": "Values or references qualified as “const” are established at _compile_ _time_, before the script starts its executions. Compilation initially occurs when saving a script in the Pine Editor, which does not require it to run on a chart. Values or references with the “const” qualifier _never change_ between script executions, not even on the first execution. All _literal_ values and the results returned by expressions involving only values qualified as “const” automatically adopt the “const” qualifier.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v5/writing/style-guide/",
            "https://www.tradingview.com/pine-script-reference/v5/#kw_var",
            "https://www.tradingview.com/pine-script-docs/v5/language/variable-declarations/#var",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_indicator",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_plot",
            "https://www.tradingview.com/pine-script-reference/v5/#var_syminfo.ticker",
            "https://www.tradingview.com/pine-script-reference/v5/#type_const",
            "https://www.tradingview.com/pine-script-reference/v5/#op_+="
          ]
        },
        {
          "type": "Type",
          "heading": "input",
          "remarks": "Values with weaker qualifiers ('const') are allowed where 'input' is expected.",
          "examples": [
            "//@version=5\nindicator(\"input demo\", overlay = true)\n//@variable The symbol to request data from. Qualified as \"input string\".\nsymbolInput = input.symbol(\"AAPL\", \"Symbol\")\n//@variable The timeframe of the data request. Qualified as \"input string\".\ntimeframeInput = input.timeframe(\"D\", \"Timeframe\")\n//@variable The source of the calculation. Qualified as \"series float\".\nsourceInput = input.source(close, \"Source\")\n//@variable The `sourceInput` value from the requested context. Qualified as \"series float\".\nrequestedSource = request.security(symbolInput, timeframeInput, sourceInput)\nplot(requestedSource)"
          ],
          "description": "Most values qualified as “input” are established after initialization via the `input.*()` functions. These functions produce values that users can modify within the “Inputs” tab of the script’s settings. When one changes any of the values in this tab, the script _restarts_ from the beginning of the chart’s history to ensure its inputs are consistent throughout its executions. Some of Pine’s built-in variables, such as `chart.bg_color` also use the “input” qualifier, even though `input.*()` functions do not return them, since the script receives their values at _input time_.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#var_chart.bg_color",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_request.security"
          ]
        },
        {
          "type": "Type",
          "heading": "simple",
          "remarks": "Wherever a script allows “simple” values, it can also accept values qualified as “input” or “const”.",
          "examples": [
            "//@version=5\nindicator(\"simple demo\", overlay = true)\n//@variable Is `true` when the current chart is non-standard. Qualified as \"simple bool\".\nisNonStandard = not chart.is_standard\n//@variable Is orange when the the current chart is non-standard. Qualified as \"simple color\".\nsimple color warningColor = isNonStandard ? color.new(color.orange, 70) : na\n// Colors the chart's background to warn that it's a non-standard chart type.\nbgcolor(warningColor, title = \"Non-standard chart color\")"
          ],
          "description": "Values qualified as “simple” are available on the first script execution, and they remain consistent across subsequent executions. Users can explicitly define variables and parameters that accept “simple” values by including the `simple` keyword in their declaration. Many built-in variables return “simple” qualified values because they depend on information that a script can only obtain once it starts running on the chart. Additionally, many built-in functions require “simple” arguments that do not change over time.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#var_chart.is_standard",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_bgcolor"
          ]
        },
        {
          "type": "Type",
          "heading": "series",
          "remarks": "Wherever a script allows “series” values, it will also accept values with any other qualifier, as “series” is the _highest_ qualifier on the hierarchy.",
          "examples": [
            "//@version=5\nindicator(\"series demo\", overlay = true)\n//@variable The source value to calculate on. Qualified as \"series float\".\nseries float sourceInput = input.source(close, \"Source\")\n//@variable The number of bars in the calculation. Qualified as \"input int\".\nlengthInput = input.int(20, \"Length\")\n//@variable The highest `sourceInput` value over `lengthInput` bars. Qualified as \"series float\".\nseries float highest = ta.highest(sourceInput, lengthInput)\n//@variable The lowest `sourceInput` value over `lengthInput` bars. Qualified as \"series float\".\nlowest = ta.lowest(sourceInput, lengthInput)\nplot(highest, \"Highest source\", color.green)\nplot(lowest, \"Lowest source\", color.red)"
          ],
          "description": "Values qualified as “series” provide the most flexibility in scripts since they can change across executions. Users can explicitly define variables and parameters that accept “series” values by including the `series` keyword in their declarations. Built-in variables such as `open`, `high`, `low`, `close`, `volume`, `time`, and `bar_index`, and the result from any expression using such built-ins, are qualified as “series”. The result of any function or operation that returns a dynamic value will always be a “series”, as will the results from using the history-referencing operator `[]` to access historical values.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#var_open",
            "https://www.tradingview.com/pine-script-reference/v5/#var_high",
            "https://www.tradingview.com/pine-script-reference/v5/#var_low",
            "https://www.tradingview.com/pine-script-reference/v5/#var_close",
            "https://www.tradingview.com/pine-script-reference/v5/#var_volume",
            "https://www.tradingview.com/pine-script-reference/v5/#var_time",
            "https://www.tradingview.com/pine-script-reference/v5/#var_bar_index",
            "https://www.tradingview.com/pine-script-reference/v5/#op_[]",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_ta.highest",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_ta.lowest"
          ]
        },
        {
          "type": "Type",
          "heading": "int",
          "remarks": "Built-in variables such as `bar_index`, `time`, `timenow`, `dayofmonth`, and `strategy.wintrades` all return values of the “int” type. Can be auto-cast to 'float' and 'bool'.",
          "examples": [
            "1\n-1\n750"
          ],
          "description": "Values of the “int” type represent integers, i.e., whole numbers without any fractional quantities. Integer literals are numeric values written in _decimal_ notation.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#var_bar_index",
            "https://www.tradingview.com/pine-script-reference/v5/#var_time",
            "https://www.tradingview.com/pine-script-reference/v5/#var_timenow",
            "https://www.tradingview.com/pine-script-reference/v5/#var_dayofmonth",
            "https://www.tradingview.com/pine-script-reference/v5/#var_strategy.wintrades"
          ]
        },
        {
          "type": "Type",
          "heading": "float",
          "remarks": "The internal precision of “float” values in Pine Script is 1e-16. Built-in variables such as `close`, `hlcc4`, `volume`, `ta.vwap`, and `strategy.position_size` all return values of the “float” type. Can be auto-cast to 'bool'. 'int' can be auto-cast to 'float'.",
          "examples": [
            "3.14159   // Rounded value of Pi (π)\n- 3.0\n6.02e23    // 6.02 * 10^23 (a very large value)\n1.6e-19    // 1.6 * 10^-19 (a very small value)"
          ],
          "description": "Values of the “float” type represent floating-point numbers, i.e., numbers that can contain whole and fractional quantities. Floating-point literals are numeric values written with a `.` delimiter. They may also contain the symbol `e` or `E` (which means “10 raised to the power of X”, where X is the number after the `e` or `E` symbol).",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#var_close",
            "https://www.tradingview.com/pine-script-reference/v5/#var_hlcc4",
            "https://www.tradingview.com/pine-script-reference/v5/#var_volume",
            "https://www.tradingview.com/pine-script-reference/v5/#var_ta.vwap",
            "https://www.tradingview.com/pine-script-reference/v5/#var_strategy.position_size"
          ]
        },
        {
          "type": "Type",
          "heading": "bool",
          "remarks": "When an expression of the “bool” type returns `na`, scripts treat its value as `false` when evaluating conditional statements and operators. Built-in variables such as `barstate.isfirst`, `chart.is_heikinashi`, `session.ismarket`, and `timeframe.isdaily` all return values of the “bool” type. 'int' and 'float' can be auto-cast to 'bool' (0 becomes false, others true), though this is discouraged and may raise warnings; use `bool()` for explicit casting.",
          "examples": [
            "true    // true value\nfalse   // false value"
          ],
          "description": "Values of the “bool” type represent the truth value of a comparison or condition, which scripts can use in conditional structures and other expressions. There are only two literals that represent boolean values: `true` and `false`.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v5/language/conditional-structures/",
            "https://www.tradingview.com/pine-script-reference/v5/#var_na",
            "https://www.tradingview.com/pine-script-reference/v5/#var_barstate.isfirst",
            "https://www.tradingview.com/pine-script-reference/v5/#var_chart.is_heikinashi",
            "https://www.tradingview.com/pine-script-reference/v5/#var_session.ismarket",
            "https://www.tradingview.com/pine-script-reference/v5/#var_timeframe.isdaily"
          ]
        },
        {
          "type": "Type",
          "heading": "color",
          "remarks": "Hexadecimal letters can be uppercase or lowercase. Pine Script has built-in color constants (e.g., `color.green`, `color.red`). Transparency can be added to constants using `color.new()`. When using `color.*()` functions, RGB components are 'int' or 'float' from 0-255, and transparency is 0 (opaque) to 100 (transparent).",
          "examples": [
            "#000000      // black color\n#FF0000      // red color\n#00FF00      // green color\n#0000FF      // blue color\n#FFFFFF      // white color\n#808080      // gray color\n#3ff7a0      // some custom color\n#FF000080    // 50% transparent red color\n#FF0000ff    // same as #FF0000, fully opaque red color\n#FF000000    // completely transparent red color",
            "//@version=5\nindicator(\"Shading the chart's background\", overlay = true)\n//@variable A \"const color\" value representing the base for each day's color.\ncolor BASE_COLOR = color.rgb(0, 99, 165)\n//@variable A \"series int\" value that modifies the transparency of the `BASE_COLOR` in `color.new()`.\nint transparency = 50 + int(40 * dayofweek / 7)\n// Color the background using the modified `BASE_COLOR`.\nbgcolor(color.new(BASE_COLOR, transparency))"
          ],
          "description": "Values of the 'color' type represent colors used for plotting and drawing. Color literals have the format: `#RRGGBB` or `#RRGGBBAA`. The letter pairs represent _hexadecimal_ values between `00` and `FF` (0 to 255 in decimal) where `RR`, `GG`, `BB` are red, green, blue components, and `AA` is optional opacity (alpha), `00` being invisible and `FF` opaque. If `AA` is omitted, it defaults to `FF` (opaque).",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v5/concepts/colors/#constant-colors",
            "https://www.tradingview.com/pine-script-reference/v5/#const_color{dot}green",
            "https://www.tradingview.com/pine-script-reference/v5/#const_color{dot}red",
            "https://www.tradingview.com/pine-script-reference/v5/#const_color{dot}orange",
            "https://www.tradingview.com/pine-script-reference/v5/#const_color{dot}blue",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#drawing-types",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_color.new",
            "https://www.tradingview.com/pine-script-docs/v5/concepts/colors/"
          ]
        },
        {
          "type": "Type",
          "heading": "string",
          "remarks": "Escape the enclosing delimiter using a backslash (`\\`). The newline character (`\\n`) can be used for multi-line text in `plot*()`, `log.*()`, and drawing types. The `+` operator concatenates strings. The `str.*()` namespace provides functions for string operations (e.g., `str.format()`). Built-in variables like `syminfo.tickerid`, `syminfo.currency`, and `timeframe.period` return strings.",
          "examples": [
            "\"This is a string literal using double quotes.\"\n'This is a string literal using single quotes.'",
            "\"It's an example\"\n'The \"Star\" indicator'",
            "'It\\'s an example'\n\"The \\\"Star\\\" indicator\"",
            "\"This\\nString\\nHas\\nOne\\nWord\\nPer\\nLine\"",
            "\"This is a \" + \"concatenated string.\"",
            "//@version=5\nindicator(\"Formatted string demo\", overlay = true)\n//@variable A \"series string\" value representing the bar's OHLC data.\nstring ohlcString = str.format(\"Open: {0}\\nHigh: {1}\\nLow: {2}\\nClose: {3}\", open, high, low, close)\n// Draw a label containing the `ohlcString`.\nlabel.new(bar_index, high, ohlcString, textcolor = color.white)"
          ],
          "description": "Values of the “string” type represent sequences of letters, numbers, symbols, spaces, and other characters. String literals in Pine are characters enclosed in single or double quotation marks. Single and double quotation marks are functionally equivalent. A string enclosed in one type can contain the other type without escaping.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#drawing-types",
            "https://www.tradingview.com/pine-script-reference/v5/#op_+",
            "https://www.tradingview.com/pine-script-docs/v5/concepts/text-and-shapes/",
            "https://www.tradingview.com/pine-script-reference/v5/#var_syminfo.tickerid",
            "https://www.tradingview.com/pine-script-reference/v5/#var_syminfo.currency",
            "https://www.tradingview.com/pine-script-reference/v5/#var_timeframe.period"
          ]
        },
        {
          "type": "Type",
          "heading": "plot and hline",
          "remarks": "Their IDs can be assigned to variables for use with the built-in `fill()` function. There is no `plot` or `hline` keyword to explicitly declare variables of these types. Plot display location can be controlled via `display.*` variables and the `force_overlay` parameter. Values from one script's plots can be used as external inputs in another script via `input.source()`.",
          "examples": [
            "//@version=5\nindicator(\"plot fill demo\", overlay = true)\n//@variable A \"series float\" value representing a 10-bar EMA of `close`.\nfloat emaFast = ta.ema(close, 10)\n//@variable A \"series float\" value representing a 20-bar EMA of `close`.\nfloat emaSlow = ta.ema(close, 20)\n//@variable The plot of the `emaFast` value.\nemaFastPlot = plot(emaFast, \"Fast EMA\", color.orange, 3)\n//@variable The plot of the `emaSlow` value.\nemaSlowPlot = plot(emaSlow, \"Slow EMA\", color.gray, 3)\n// Fill the space between the `emaFastPlot` and `emaSlowPlot`.\nfill(emaFastPlot, emaSlowPlot, color.new(color.purple, 50), \"EMA Fill\")"
          ],
          "description": "Pine Script’s `plot()` and `hline()` functions return IDs that respectively reference instances of the “plot” and “hline” types. These types display calculated values and horizontal levels on the chart.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#fun_plot",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_hline",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_fill",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_input.source",
            "https://www.tradingview.com/pine-script-docs/v5/concepts/inputs/#source-input"
          ]
        },
        {
          "type": "Type",
          "heading": "Drawing types",
          "remarks": "Drawing IDs are always qualified as 'series' (e.g., 'series line', 'series label').",
          "examples": [],
          "description": "Pine Script drawing types allow scripts to create custom drawings on charts. They include: `line`, `linefill`, `box`, `polyline`, `label`, and `table`. Each type has a namespace containing built-ins to create and manage drawing instances (e.g., `line.new()`, `label.new()`, `table.new()`). These functions return an _ID_ (qualified as 'series') which uniquely identifies the drawing object and acts like a pointer for managing the object (e.g., deleting with `line.delete()`).",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#type_line",
            "https://www.tradingview.com/pine-script-reference/v5/#type_linefill",
            "https://www.tradingview.com/pine-script-reference/v5/#type_box",
            "https://www.tradingview.com/pine-script-reference/v5/#type_polyline",
            "https://www.tradingview.com/pine-script-reference/v5/#type_label",
            "https://www.tradingview.com/pine-script-reference/v5/#type_table",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_line.new",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_linefill.new",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_box.new",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_polyline.new",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_label.new",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_table.new",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_line.delete"
          ]
        },
        {
          "type": "Type",
          "heading": "Chart points",
          "remarks": "Whether a drawing instance uses the `time` or `index` field as an x-coordinate depends on its `xloc` property. Functions to create chart points include: `chart.point.new()`, `chart.point.now()`, `chart.point_from_index()`, `chart.point.from_time()`, and `chart.point.copy()`. Points created with `from_index` have `na` for `time` and won't work with `xloc.bar_time`. Points created with `from_time` have `na` for `index` and won't work with `xloc.bar_index`.",
          "examples": [
            "//@version=5\nindicator(\"Chart points demo\", overlay = true)\n//@variable A new `chart.point` at the previous `bar_index` and `high`.\nfirstPoint = chart.point.from_index(bar_index - 1, high[1])\n//@variable A new `chart.point` at the current bar's `low`.\nsecondPoint = chart.point.now(low)\n// Draw a new line connecting coordinates from the `firstPoint` and `secondPoint`.\n// This line uses the `index` fields from the points as x-coordinates.\nline.new(firstPoint, secondPoint, color = color.purple, width = 3)\n// Draw a label at the `firstPoint`. Uses the point's `index` field as its x-coordinate.\nlabel.new(\n     firstPoint, str.tostring(firstPoint.price), color = color.green,\n     style = label.style_label_down, textcolor = color.white\n)\n// Draw a label at the `secondPoint`. Uses the point's `index` field as its x-coordinate.\nlabel.new(\n     secondPoint, str.tostring(secondPoint.price), color = color.red,\n     style = label.style_label_up, textcolor = color.white\n)"
          ],
          "description": "Chart points are special types (`chart.point`) that represent coordinates on the chart. Scripts use information from `chart.point` objects to determine the chart locations of lines, boxes, polylines, and labels. Objects of this type contain three _fields_: `time`, `index`, and `price`.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#type_chart.point",
            "https://www.tradingview.com/pine-script-docs/v5/concepts/lines-and-boxes/#lines",
            "https://www.tradingview.com/pine-script-docs/v5/concepts/lines-and-boxes/#boxes",
            "https://www.tradingview.com/pine-script-docs/v5/concepts/lines-and-boxes/#polylines",
            "https://www.tradingview.com/pine-script-docs/v5/concepts/text-and-shapes/#labels",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_chart.point.new",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_chart.point.now",
            "https://www.tradingview.com/pine-script-reference/v5/#var_time",
            "https://www.tradingview.com/pine-script-reference/v5/#var_bar_index",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_chart.point.from_index",
            "https://www.tradingview.com/pine-script-reference/v5/#var_na",
            "https://www.tradingview.com/pine-script-reference/v5/#var_xloc.bar_time",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_chart.point.from_time",
            "https://www.tradingview.com/pine-script-reference/v5/#var_xloc.bar_index",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_chart.point.copy",
            "https://www.tradingview.com/pine-script-reference/v5/#var_high",
            "https://www.tradingview.com/pine-script-reference/v5/#var_low"
          ]
        },
        {
          "type": "Type",
          "heading": "Collections",
          "remarks": "Examples of type templates: `array<int>`, `array<label>`, `array<UDT>`, `matrix<float>`, `matrix<UDT>`, `map<string, float>`, `map<int, UDT>`. The `int[]` syntax for arrays is discouraged. Type-specific constructors like `array.new_int()` exist but the generic `array.new<type>()` form (e.g., `array.new<int>()`) is preferred.",
          "examples": [
            "a1 = array.new<int>(1, 10)\narray<int> a2 = array.new<int>(1, 10)\na3 = array.from(10)\narray<int> a4 = array.from(10)"
          ],
          "description": "Collections in Pine Script (arrays, matrices, and maps) utilize reference IDs, similar to other special types. The type of the ID defines the type of _elements_ the collection will contain. Collection types are specified by appending a type template to the `array`, `matrix`, or `map` keywords.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v5/language/arrays/",
            "https://www.tradingview.com/pine-script-docs/v5/language/matrices/",
            "https://www.tradingview.com/pine-script-docs/v5/language/maps/",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#type-templates",
            "https://www.tradingview.com/pine-script-reference/v5/#type_array",
            "https://www.tradingview.com/pine-script-reference/v5/#type_matrix",
            "https://www.tradingview.com/pine-script-reference/v5/#type_map",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#user-defined-types",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_array{dot}new_int",
            "https://www.tradingview.com/pine-script-reference/v5/#type_array"
          ]
        },
        {
          "type": "Type",
          "heading": "User-defined types",
          "remarks": "Syntax: `[export] type <UDT_identifier> { <field_type> <field_name>[ = <value>] ... }`. The optional `export` keyword is used in libraries. If a default `<value>` is not provided for a field, it defaults to `na`. Default values follow the same rules as function parameters (cannot use history reference `[]` or complex expressions). UDTs support recursion (fields can reference the same UDT). Use `new()` and `copy()` methods to create and copy UDT instances.",
          "examples": [
            "    //@type           A user-defined type containing pivot information.\n    //@field pivotTime  Contains time information about the pivot.\n    //@field priceLevel Contains price information about the pivot.\n    type pivotPoint\n        int   pivotTime\n        float priceLevel",
            "    //@type           A user-defined type containing pivot information.\n    //@field pivotTime  Contains time information about the pivot.\n    //@field priceLevel Contains price information about the pivot.\n    //@field nextPivot  A `pivotPoint` instance containing additional pivot information.\n    type pivotPoint\n        int        pivotTime\n        float      priceLevel\n        pivotPoint nextPivot"
          ],
          "description": "The `type` keyword allows the creation of _user-defined types_ (UDTs) from which scripts can create objects. UDTs are composite types; they contain an arbitrary number of _fields_ that can be of any type, including other user-defined types.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#kw_type",
            "https://www.tradingview.com/pine-script-docs/v5/language/objects/",
            "https://www.tradingview.com/pine-script-reference/v5/#kw_export",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_library",
            "https://www.tradingview.com/pine-script-docs/v5/concepts/libraries/#user-defined-types-and-objects",
            "https://www.tradingview.com/pine-script-reference/v5/#var_na",
            "https://www.tradingview.com/pine-script-reference/v5/#op_[]",
            "https://www.tradingview.com/pine-script-docs/v5/language/objects/"
          ]
        },
        {
          "type": "Type",
          "heading": "Enum types",
          "remarks": "Syntax: `[export] enum <enumName> { <field_1>[ = <title_1>] ... <field_N>[ = <title_N>] }`. The optional `export` keyword is for libraries. `<enumName>` can be used as a type keyword. `<field_*>` is a member name, accessed via `enumName.fieldName`. `<title_*>` is an optional 'const string' title used by `input.enum()` and retrievable with `str.tostring()`. Field names and titles must be unique within the enum. Enum members are established on the first execution and have the 'simple' qualifier.",
          "examples": [
            "//@enum       An enumeration of named values for moving average selection.\n//@field sma  Selects a Simple Moving Average.\n//@field ema  Selects an Exponential Moving Average.\n//@field wma  Selects a Weighted Moving Average.\n//@field hma  Selects a Hull Moving Average.\nenum maChoice\n    sma  = \"Simple Moving Average\"\n    ema  = \"Exponential Moving Average\"\n    wma  = \"Weighted Moving Average\"\n    hma  = \"Hull Moving Average\"",
            "//@version=5\nindicator(\"Enum types demo\", overlay = true)\n//@enum       An enumeration of named values for moving average selection.\n//@field sma  Selects a Simple Moving Average.\n//@field ema  Selects an Exponential Moving Average.\n//@field wma  Selects a Weighted Moving Average.\n//@field hma  Selects a Hull Moving Average.\nenum maChoice\n    sma  = \"Simple Moving Average\"\n    ema  = \"Exponential Moving Average\"\n    wma  = \"Weighted Moving Average\"\n    hma  = \"Hull Moving Average\"\n//@variable The `maChoice` member representing a selected moving average name.\nmaChoice maInput = input.enum(maChoice.sma, \"Moving average type\")\n//@variable The length of the moving average.\nint lengthInput = input.int(20, \"Length\", 1, 4999)\n//@variable The moving average selected by the `maInput`.\nfloat selectedMA = switch maInput\n    maChoice.sma => ta.sma(close, lengthInput)\n    maChoice.ema => ta.ema(close, lengthInput)\n    maChoice.wma => ta.wma(close, lengthInput)\n    maChoice.hma => ta.hma(close, lengthInput)\n// Plot the `selectedMA`.\nplot(selectedMA, \"Selected moving average\", color.teal, 3)"
          ],
          "description": "The `enum` keyword allows the creation of an _enum_ (enumeration or enumerated type). An enum is a unique type construct containing distinct, named fields representing _members_ (possible values) of the type. Enums allow control over accepted values for variables, conditions, collections, and facilitate dropdown input creation with `input.enum()`.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#kw_enum",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#collections",
            "https://www.tradingview.com/pine-script-docs/v5/concepts/inputs/#enum-input",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_input.enum",
            "https://www.tradingview.com/pine-script-reference/v5/#kw_export",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_library",
            "https://www.tradingview.com/pine-script-docs/v5/concepts/libraries/#enum-types",
            "https://www.tradingview.com/pine-script-docs/v5/language/variable-declarations/",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#type-templates",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_str.tostring",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#simple",
            "https://www.tradingview.com/pine-script-reference/v5/#kw_switch",
            "https://www.tradingview.com/pine-script-docs/v5/language/enums/",
            "https://www.tradingview.com/pine-script-docs/v5/concepts/inputs/"
          ]
        },
        {
          "type": "Type",
          "heading": "void",
          "remarks": "Scripts cannot use “void” results in expressions or assign them to variables. No `void` keyword exists in Pine Script since one cannot declare a variable of the “void” type.",
          "examples": [],
          "description": "There is a “void” type in Pine Script. Functions having only side-effects and returning no usable result return the “void” type. An example of such a function is `alert()`; it does something (triggers an alert event), but it returns no usable value.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#fun_alert"
          ]
        },
        {
          "type": "Value",
          "heading": "`na` value",
          "remarks": "`na` values can be automatically cast to almost any type, but sometimes explicit type declaration or casting (e.g., `float myVar = na` or `myVar = float(na)`) is needed if the compiler cannot infer the type. Use the `na()` function to test if a value is `na`; do not use the `==` operator. Use functions like `nz()` to handle `na` values in calculations and prevent them from propagating.",
          "examples": [
            "// Compilation error!\nmyVar = na",
            "float myVar = na",
            "myVar = float(na)",
            "//@variable Is 0 if the `myVar` is `na`, `close` otherwise.\nfloat myClose = na(myVar) ? 0 : close",
            "//@variable Returns the `close` value. The script cannot compare the equality of `na` values, as they're undefined.\nfloat myClose = myVar == na ? 0 : close",
            "//@variable Is `true` when the `close` exceeds the last bar's `close` (or the current `open` if the value is `na`).\nbool risingClose = close > nz(close[1], open)",
            "//@version=5\nindicator(\"na protection demo\", overlay = true)\n//@variable The result of calculating the all-time high price with an initial value of `na`.\nvar float allTimeHigh = na\n// Reassign the value of the `allTimeHigh`.\n// Returns `na` on all bars because `math.max()` can't compare the `high` to an undefined value.\nallTimeHigh := math.max(allTimeHigh, high)\nplot(allTimeHigh) // Plots `na` on all bars.",
            "//@version=5\nindicator(\"na protection demo\", overlay = true)\n//@variable The result of calculating the all-time high price with an initial value of `na`.\nvar float allTimeHigh = na\n// Reassign the value of the `allTimeHigh`.\n// We've used `nz()` to prevent the initial `na` value from persisting throughout the calculation.\nallTimeHigh := math.max(nz(allTimeHigh), high)\nplot(allTimeHigh)"
          ],
          "description": "There is a special value in Pine Script called `na`, which is an acronym for _not available_. We use `na` to represent an undefined value from a variable or expression. It is similar to `null` in Java and `None` in Python.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#var_na",
            "https://www.tradingview.com/pine-script-reference/v5/#type_float",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_float",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_na",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_nz",
            "https://www.tradingview.com/pine-script-reference/v5/#var_close",
            "https://www.tradingview.com/pine-script-reference/v5/#var_open",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_math.max",
            "https://www.tradingview.com/pine-script-reference/v5/#var_high"
          ]
        },
        {
          "type": "Type",
          "heading": "Type templates",
          "remarks": "Type templates can be constructed from fundamental types (int, float, bool, color, string), special types (line, linefill, box, polyline, label, table, chart.point), User-defined types (UDTs), and Enum types. Maps can use any of these as values, but only fundamental types or enum types as keys. Scripts use type templates when declaring collection variables and creating new collection instances.",
          "examples": [
            "//@version=5\nindicator(\"Type templates demo\")\n//@variable A variable initially assigned to `na` that accepts arrays of \"int\" values.\narray<int> intArray = na\n//@variable An empty matrix that holds \"float\" values.\nfloatMatrix = matrix.new<float>()\n//@variable An empty map that holds \"string\" keys and \"color\" values.\nstringColorMap = map.new<string, color>()"
          ],
          "description": "Type templates specify the data types that collections (arrays, matrices, and maps) can contain. Templates for arrays and matrices consist of a single type identifier surrounded by angle brackets (e.g., `<int>`, `<label>`, `<UDT>`). Templates for maps consist of two type identifiers enclosed in angle brackets, specifying key type and value type (e.g., `<string, float>`).",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v5/language/arrays/",
            "https://www.tradingview.com/pine-script-docs/v5/language/matrices/",
            "https://www.tradingview.com/pine-script-docs/v5/language/maps/",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#int",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#float",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#bool",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#color",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#string",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#drawing-types",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#chart-points",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#user-defined-types",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#enum-types"
          ]
        },
        {
          "type": "Type",
          "heading": "Type casting",
          "remarks": "Use `bool()` for explicit numeric-to-boolean casting to avoid warnings and improve readability. Explicit casting functions: `int()`, `float()`, `bool()`, `color()`, `string()`, `line()`, `linefill()`, `label()`, `box()`, `table()`. Explicit casting is necessary when auto-casting rules don't apply (e.g., float to int) or when declaring variables assigned to `na`.",
          "examples": [
            "//@version=5\nindicator(\"Auto-casting demo\", overlay = true)\n//@variable A random rounded value between -1 and 1.\nfloat randomValue = math.round(math.random(-1, 1))\n//@variable The color of the chart background.\ncolor bgColor = na\n// This raises a compiler warning since `randomValue` is a \"float\", but `if` expects a \"bool\".\nif randomValue\n    bgColor := color.new(color.blue, 60)\n// This does not raise a warning, as the `bool()` function explicitly casts the `randomValue` to \"bool\".\nif bool(randomValue)\n    bgColor := color.new(color.blue, 60)\n// Display unicode characters on the chart based on the `randomValue`.\n// Whenever `math.random()` returns 0, no character will appear on the chart because 0 converts to `false`.\nplotchar(randomValue)\n// We recommend explicitly casting the number with the `bool()` function to make the type transformation more obvious.\nplotchar(bool(randomValue))\n// Highlight the background with the `bgColor`.\nbgcolor(bgColor)",
            "//@version=5\nindicator(\"Explicit casting demo\", overlay = true)\n//@variable The length of the SMA calculation. Qualified as \"const float\".\nfloat LENGTH = 10.0\nfloat sma = ta.sma(close, LENGTH) // Compilation error. The `length` parameter requires an \"int\" value.\nplot(sma)",
            "//@version=5\nindicator(\"explicit casting demo\")\n//@variable The length of the SMA calculation. Qualified as \"const float\".\nfloat LENGTH = 10.0\nfloat sma = ta.sma(close, int(LENGTH)) // Compiles successfully since we've converted the `LENGTH` to \"int\".\nplot(sma)",
            "// Explicitly specify that the variable references \"label\" objects:\nlabel myLabel = na\n// Explicitly cast the `na` value to the \"label\" type:\nmyLabel = label(na)"
          ],
          "description": "Pine Script includes an automatic type-casting mechanism that casts “int” values to “float” when necessary. For backward compatibility, it also auto-casts “int” and “float” to “bool” (0 becomes `false`, any other number becomes `true`), but this is discouraged and often produces compiler warnings. Explicit type casting functions are available for cases where auto-casting doesn't suffice or isn't desired.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#fun_bool",
            "https://www.tradingview.com/pine-script-reference/v5/#kw_if",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_plotchar",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_int",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_float",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_color",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_string",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_line",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_linefill",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_label",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_box",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_table",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_ta.sma",
            "https://www.tradingview.com/pine-script-reference/v5/#var_na",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#na-value"
          ]
        },
        {
          "type": "Type",
          "heading": "Tuples",
          "remarks": "Variable types in a tuple declaration are inferred automatically; they cannot be explicitly defined. Tuples can contain values of multiple types. They are useful for requesting multiple values in one `request.security()` call. Local blocks of `if` and `switch` statements can return tuples, but ternaries cannot. If any item in a returned tuple is 'series', all items become 'series'.",
          "examples": [
            "//@function Calculates the sum and product of two values.\ncalcSumAndProduct(float a, float b) =>\n    //@variable The sum of `a` and `b`.\n    float sum = a + b\n    //@variable The product of `a` and `b`.\n    float product = a * b\n    // Return a tuple containing the `sum` and `product`.\n    [sum, product]",
            "// Declare a tuple containing the sum and product of the `high` and `low`, respectively.\n[hlSum, hlProduct] = calcSumAndProduct(high, low)",
            "//@function Returns information about the current chart.\nchartInfo() =>\n    //@variable The first visible bar's UNIX time value.\n    int firstVisibleTime = chart.left_visible_bar_time\n    //@variable The `close` value at the `firstVisibleTime`.\n    float firstVisibleClose = ta.valuewhen(ta.cross(time, firstVisibleTime), close, 0)\n    //@variable Is `true` when using a standard chart type, `false` otherwise.\n    bool isStandard = chart.is_standard\n    //@variable The foreground color of the chart.\n    color fgColor = chart.fg_color\n    //@variable The ticker ID of the current chart.\n    string symbol = syminfo.tickerid\n    // Return a tuple containing the values.\n    [firstVisibleTime, firstVisibleClose, isStandard, fgColor, symbol]",
            "//@function Returns a tuple of OHLC values, rounded to the nearest tick.\nroundedOHLC() =>\n    [math.round_to_mintick(open), math.round_to_mintick(high), math.round_to_mintick(low), math.round_to_mintick(close)]\n[op, hi, lo, cl] = request.security(syminfo.tickerid, \"D\", roundedOHLC())",
            "[op, hi, lo, cl] = request.security(\n     syminfo.tickerid, \"D\",\n     [math.round_to_mintick(open), math.round_to_mintick(high), math.round_to_mintick(low), math.round_to_mintick(close)]\n)",
            "[v1, v2] = if close > open\n    [high, close]\nelse\n    [close, low]",
            "[v1, v2] = switch\nclose > open => [high, close]\n=>             [close, low]",
            "// Not allowed.\n[v1, v2] = close > open ? [high, close] : [close, low]",
            "//@version=5\nindicator(\"Qualified types in tuples demo\")\nmakeTicker(simple string prefix, simple string ticker) =>\n    tId = prefix + \":\" + ticker // simple string\n    source = close  // series float\n    [tId, source]\n// Both variables are series now.\n[tId, source] = makeTicker(\"BATS\", \"AAPL\")\n// Error cannot call 'request.security' with 'series string' tId.\nr = request.security(tId, \"\", source)\nplot(r)"
          ],
          "description": "A _tuple_ is a comma-separated set of expressions enclosed in brackets (`[]`). When a function, method, or other local block returns more than one value, scripts return those values in the form of a tuple. Use a _tuple declaration_ (e.g., `[var1, var2] = functionCall()`) to assign the returned values to multiple variables.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v5/language/methods/",
            "https://www.tradingview.com/pine-script-docs/v5/language/user-defined-functions/",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_request.security",
            "https://www.tradingview.com/pine-script-reference/v5/#var_syminfo.mintick",
            "https://www.tradingview.com/pine-script-docs/v5/language/conditional-structures/",
            "https://www.tradingview.com/pine-script-reference/v5/#kw_if",
            "https://www.tradingview.com/pine-script-reference/v5/#kw_switch"
          ]
        },
        {
          "type": "Function",
          "heading": "Methods",
          "remarks": "Pine Script includes built-in methods for special types (array, matrix, map, line, linefill, box, polyline, label, table). Users can define custom methods using the `method` keyword, where the first parameter's type must be explicitly declared. User-defined methods can overload existing built-in or user-defined methods.",
          "examples": [
            "// Built-in method usage\n//@version=5\nindicator(\"Custom Sample BB\", overlay = true)\nfloat sourceInput  = input.source(close, \"Source\")\nint   samplesInput = input.int(20, \"Samples\")\nint   n            = input.int(10, \"Bars\")\nfloat multiplier   = input.float(2.0, \"StdDev\")\nvar array<float> sourceArray = array.new<float>(samplesInput)\nvar float        sampleMean  = na\nvar float        sampleDev   = na\n// Identify if `n` bars have passed.\nif bar_index % n == 0\n    // Update the queue.\n    sourceArray.push(sourceInput)\n    sourceArray.shift()\n    // Update the mean and standard deviaiton values.\n    sampleMean := sourceArray.avg()\n    sampleDev  := sourceArray.stdev() * multiplier\n// Calculate band values.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand  = sampleMean - sampleDev\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)",
            "// User-defined method definition and usage\n//@version=5\nindicator(\"Custom Sample BB\", overlay = true)\nfloat sourceInput  = input.source(close, \"Source\")\nint   samplesInput = input.int(20, \"Samples\")\nint   n            = input.int(10, \"Bars\")\nfloat multiplier   = input.float(2.0, \"StdDev\")\nvar array<float> sourceArray = array.new<float>(samplesInput)\n// @function         Maintains a queue of the size of `srcArray`.\n//                   It appends a `value` to the array and removes its oldest element at position zero.\n// @param srcArray   (array<float>) The array where the queue is maintained.\n// @param value      (float) The new value to be added to the queue.\n//                   The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new `value` is only pushed into the queue if this is true.\n// @returns          (array<float>) `srcArray` object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\n    if takeSample\n        srcArray.push(value)\n        srcArray.shift()\n    srcArray\n// @function         Computes Bollinger Band values from an array of data.\n// @param srcArray   (array<float>) The array where the queue is maintained.\n// @param multiplier (float) Standard deviaiton multiplier.\n// @param calcuate   (bool) The method will only calculate new values when this is true.\n// @returns          A tuple containing the basis, upper band, and lower band respectively.\nmethod calcBB(array<float> srcArray, float mult, bool calculate = true) =>\n    var float mean = na\n    var float dev  = na\n    if calculate\n        // Compute the mean and standard deviation of the array.\n        mean := srcArray.avg()\n        dev  := srcArray.stdev() * mult\n    [mean, mean + dev, mean - dev]\n// Identify if `n` bars have passed.\nbool newSample = bar_index % n == 0\n// Update the queue and compute new BB values on each new sample.\n[sampleMean, highBand, lowBand] = sourceArray.maintainQueue(sourceInput, newSample).calcBB(multiplier, newSample)\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)",
            "// Method overloading example\n//@version=5\nindicator(\"Type Inspection\")\n// @function   Identifies an object's type.\n// @param this Object to inspect.\n// @returns    (string) A string representation of the type.\nmethod getType(int this) =>\n    na(this) ? \"int(na)\" : \"int\"\nmethod getType(float this) =>\n    na(this) ? \"float(na)\" : \"float\"\nmethod getType(bool this) =>\n    na(this) ? \"bool(na)\" : \"bool\"\nmethod getType(color this) =>\n    na(this) ? \"color(na)\" : \"color\"\nmethod getType(string this) =>\n    na(this) ? \"string(na)\" : \"string\"\na = 1\nb = 1.0\nc = true\nd = color.white\ne = \"1\"\n// Inspect variables and format results.\nresults = str.format(\n \"a: {0}\\nb: {1}\\nc: {2}\\nd: {3}\\ne: {4}\",\n a.getType(), b.getType(), c.getType(), d.getType(), e.getType()\n)\nvar label lbl = label.new(0, 0)\nlbl.set_x(bar_index)\nlbl.set_text(results)"
          ],
          "description": "Pine Script methods are specialized functions associated with values of specific built-in types, user-defined types, or enum types. They behave the same as regular functions in most regards while offering a shorter, more convenient syntax using dot notation.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#types",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#user-defined-types",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#enum-types",
            "https://www.tradingview.com/pine-script-docs/v5/language/objects/",
            "https://www.tradingview.com/pine-script-reference/v5/#type_array",
            "https://www.tradingview.com/pine-script-reference/v5/#type_matrix",
            "https://www.tradingview.com/pine-script-reference/v5/#type_map",
            "https://www.tradingview.com/pine-script-reference/v5/#type_line",
            "https://www.tradingview.com/pine-script-reference/v5/#type_linefill",
            "https://www.tradingview.com/pine-script-reference/v5/#type_box",
            "https://www.tradingview.com/pine-script-reference/v5/#type_polyline",
            "https://www.tradingview.com/pine-script-reference/v5/#type_label",
            "https://www.tradingview.com/pine-script-reference/v5/#type_table",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_array.get",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_array.push",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_array.shift",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_array.avg",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_array.stdev",
            "https://www.tradingview.com/pine-script-reference/v5/#kw_method",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_array.fill",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_array.min",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_array.range"
          ]
        },
        {
          "type": "Keyword",
          "heading": "User-defined methods",
          "remarks": "The type of the first parameter in the signature must be explicitly declared, as it represents the type of object that the method will be associated with. Syntax: `[export] method <functionName>(<paramType> <paramName> [= <defaultValue>], …) => <functionBlock>`",
          "examples": [
            "// Defining a user-defined method\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\n    if takeSample\n        srcArray.push(value)\n        srcArray.shift()\n    srcArray",
            "// Defining another user-defined method\nmethod calcBB(array<float> srcArray, float mult, bool calculate = true) =>\n    var float mean = na\n    var float dev  = na\n    if calculate\n        mean := srcArray.avg()\n        dev  := srcArray.stdev() * mult\n    [mean, mean + dev, mean - dev]"
          ],
          "description": "The `method` keyword must be included before the function name when defining a user-defined method.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#kw_method"
          ]
        },
        {
          "type": "Type",
          "heading": "Types",
          "remarks": "Pine Script includes built-in methods for many special types. User-defined methods must explicitly declare the type of the first parameter, which links the method to that type. Method overloading allows defining methods with the same name for different types.",
          "examples": [
            "var array<float> sourceArray = array.new<float>(samplesInput) // Array type\nsourceArray.push(sourceInput) // Method call on array object",
            "method getType(int this) => ... // Method defined for int type\nmethod getType(float this) => ... // Method defined for float type\nmethod getType(bool this) => ... // Method defined for bool type\nmethod getType(color this) => ... // Method defined for color type\nmethod getType(string this) => ... // Method defined for string type"
          ],
          "description": "Methods are associated with values of specific built-in types (e.g., array, matrix, map, line, label, table, int, float, bool, color, string), user-defined types, or enum types.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#types",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#user-defined-types",
            "https://www.tradingview.com/pine-script-docs/v5/language/type-system/#enum-types",
            "https://www.tradingview.com/pine-script-reference/v5/#type_array",
            "https://www.tradingview.com/pine-script-reference/v5/#type_matrix",
            "https://www.tradingview.com/pine-script-reference/v5/#type_map",
            "https://www.tradingview.com/pine-script-reference/v5/#type_line",
            "https://www.tradingview.com/pine-script-reference/v5/#type_linefill",
            "https://www.tradingview.com/pine-script-reference/v5/#type_box",
            "https://www.tradingview.com/pine-script-reference/v5/#type_polyline",
            "https://www.tradingview.com/pine-script-reference/v5/#type_label",
            "https://www.tradingview.com/pine-script-reference/v5/#type_table"
          ]
        },
        {
          "type": "Annotation",
          "heading": "User-defined methods",
          "remarks": "These annotations help in generating documentation and improving code readability. They appear in comments before the method definition.",
          "examples": [
            "// @function         Maintains a queue of the size of `srcArray`.\n//                   It appends a `value` to the array and removes its oldest element at position zero.\n// @param srcArray   (array<float>) The array where the queue is maintained.\n// @param value      (float) The new value to be added to the queue.\n//                   The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new `value` is only pushed into the queue if this is true.\n// @returns          (array<float>) `srcArray` object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\n    if takeSample\n        srcArray.push(value)\n        srcArray.shift()\n    srcArray"
          ],
          "description": "Compiler annotations like `@function`, `@param`, and `@returns` are used to document user-defined methods, similar to how they are used for user-defined functions.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v5/language/script-structure/#compiler-annotations"
          ]
        },
        {
          "type": "Variable/Function",
          "heading": "Functions and the variable `time`",
          "remarks": "The `time` variable is in UTC, while the `time` function uses the exchange timezone for session specification unless otherwise specified. An overloaded `time(resolution)` function uses the symbol's regular session.",
          "examples": [
            "`study(\"Bar date/time\")\nplot(time)`",
            "`study(\"Session bars\")\nt = time(period, \"0930-1600\")\nplot(na(t) ? 0 : 1)`",
            "`//version=3\nstudy(\"new 30 min bar\")\nis_newbar(res) =>\n    t = time(res)\n    not na(t) and (na(t[1]) or t > t[1])\nplot(is_newbar(\"30\") ? 1 : 0)`",
            "`//@version=3\nstudy(\"Opening high/low\", overlay=true)\nhighTimeFrame = input(\"D\", type=resolution)\nsessSpec = input(\"0930-1600\", type=session)\nis_newbar(res, sess) =>\n    t = time(res, sess)\n    na(t[1]) and not na(t) or t[1] < t\nnewbar = is_newbar(\"1440\", sessSpec)\ns1 = na\ns1 := newbar ? low : nz(s1[1])\ns2 = na\ns2 := newbar ? high : nz(s2[1])\nplot(s1, style=circles, linewidth=3, color=red)\nplot(s2, style=circles, linewidth=3, color=lime)`",
            "Session Examples:\n“0000-0000”\n“1700-1700”\n“0900-1600,1700-2000”\n“2000-1630”\n“0930-1700:146”\n“24x7”\n“0000-0000:1234567”\n“0000-0000:23456”\n“1700-1700”\n“1000-1001:26”"
          ],
          "description": "Discusses the `time` variable (UNIX timestamp of bar start in ms, UTC) and the `time(resolution, session)` function (returns bar start time in ms or `na` if outside the specified session). Explains session specification strings.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v3/#var_time",
            "https://www.tradingview.com/pine-script-reference/v3/#fun_time",
            "https://www.tradingview.com/pine-script-reference/v3/#fun_input"
          ]
        },
        {
          "type": "Variable/Function/Constant",
          "heading": "Built-in variables for working with time",
          "remarks": "All variables and functions return time in the exchange time zone, except for `time` and `timenow` which are in UTC.",
          "examples": [],
          "description": "Lists built-in variables and functions for time manipulation. Basic variables: `time` (UTC), `timenow` (UTC), `syminfo.timezone`. Bar time variables (exchange timezone): `year`, `month`, `weekofyear`, `dayofmonth`, `dayofweek` (with constants `sunday` to `saturday`), `hour`, `minute`, `second`. Time construction functions (exchange timezone): `year(t)`, `month(t)`, `weekofyear(t)`, `dayofmonth(t)`, `dayofweek(t)`, `hour(t)`, `minute(t)`, `second(t)`, `timestamp()`.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v3/#var_time",
            "https://www.tradingview.com/pine-script-reference/v3/#var_timenow",
            "https://www.tradingview.com/pine-script-reference/v3/#var_syminfo%7Bdot%7Dtimezone",
            "https://www.tradingview.com/pine-script-reference/v3/#var_year",
            "https://www.tradingview.com/pine-script-reference/v3/#var_month",
            "https://www.tradingview.com/pine-script-reference/v3/#var_weekofyear",
            "https://www.tradingview.com/pine-script-reference/v3/#var_dayofmonth",
            "https://www.tradingview.com/pine-script-reference/v3/#var_dayofweek",
            "https://www.tradingview.com/pine-script-reference/v3/#var_hour",
            "https://www.tradingview.com/pine-script-reference/v3/#var_minute",
            "https://www.tradingview.com/pine-script-reference/v3/#var_second",
            "https://www.tradingview.com/pine-script-reference/v3/#fun_year",
            "https://www.tradingview.com/pine-script-reference/v3/#fun_month",
            "https://www.tradingview.com/pine-script-reference/v3/#fun_weekofyear",
            "https://www.tradingview.com/pine-script-reference/v3/#fun_dayofmonth",
            "https://www.tradingview.com/pine-script-reference/v3/#fun_dayofweek",
            "https://www.tradingview.com/pine-script-reference/v3/#fun_hour",
            "https://www.tradingview.com/pine-script-reference/v3/#fun_minute",
            "https://www.tradingview.com/pine-script-reference/v3/#fun_second",
            "https://www.tradingview.com/pine-script-reference/v3/#fun_timestamp"
          ]
        },
        {
          "type": "Annotations",
          "heading": "Custom OHLC bars and candles",
          "remarks": "This technique allows for visual representation of custom data series or modified standard OHLC data. Key functions involved are `plotbar` (for bars) and `plotcandle` (for candles), both requiring four series arguments (open, high, low, close). Customization includes color control based on conditions (e.g., `close >= open`), handling of `na` values (bars with `na` in any OHLC component are not plotted), plotting smoothed data (e.g., using `sma`), and displaying data from higher timeframes using the `security` function. The `title` argument helps identify plots in the script settings.",
          "examples": [
            "study(\"Example 1\")\nplotbar(open, high, low, close)",
            "study(\"Example 2\")\npalette = close >= open ? lime : red\nplotbar(open, high, low, close, color=palette)",
            "study(\"Example 3\")\nc = close > open ? na : close\nplotcandle(open, high, low, c)",
            "study(\"Example 4\")\nlen = input(9)\nsmooth(x) =>\n    sma(x, len)\no = smooth(open)\nh = smooth(high)\nl = smooth(low)\nc = smooth(close)\nplotcandle(o, h, l, c)",
            "// NOTE: add this script on intraday chart\nstudy(\"Example 5\")\nhigherRes = input(\"D\", type=resolution)\nis_newbar(res) =>\n    t = time(res)\n    not na(t) and (na(t[1]) or t > t[1])\no = security(tickerid, higherRes, open)\nh = security(tickerid, higherRes, high)\nl = security(tickerid, higherRes, low)\nc = security(tickerid, higherRes, close)\nplotbar(is_newbar(higherRes) ? o : na, h, l, c, color=c >= o ? lime : red)"
          ],
          "description": "Explains how to create custom Open-High-Low-Close (OHLC) bars and candles on a TradingView chart using Pine Script functions `plotbar` and `plotcandle`.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v3/#fun_plotbar",
            "https://www.tradingview.com/pine-script-reference/v3/#fun_plotcandle"
          ]
        },
        {
          "type": "Annotations",
          "heading": "Price levels, `hline`",
          "remarks": "A _number_ must be the first argument of `hline`. Values of a _series_ type are forbidden. It’s possible to create a few horizontal lines with the help of `hline` and fill in the background between them with a translucent light using the function [fill](https://www.tradingview.com/pine-script-reference/v3/#fun_fill).",
          "examples": [
            "study(title=\"Chaikin Oscillator\", shorttitle=\"Chaikin Osc\")\nshort = input(3,minval=1), long = input(10,minval=1)\nosc = ema(accdist, short) - ema(accdist, long)\nplot(osc, color=red)\nhline(0, title=\"Zero\", color=gray, linestyle=dashed)"
          ],
          "description": "The annotation function [hline](https://www.tradingview.com/pine-script-reference/v3/#fun_hline) renders a horizontal line at a given fixed price level.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v3/#fun_hline",
            "https://www.tradingview.com/pine-script-reference/v3/#fun_fill"
          ]
        },
        {
          "type": "Annotations",
          "heading": "Plot annotation",
          "remarks": "The `offset` parameter specifies a visual shift for the plotted line (negative values shift left, positive values shift right). This shift is purely cosmetic; the actual series values are not moved. This differs from the built-in `offset` function, which shifts series values to the right and discards 'out of range' values, allowing the result to be used in further calculations.",
          "examples": [
            "plot(close)",
            "plot(125.2)",
            "plot(close, color=color.red)",
            "    c = close >= open ? color.lime : color.red\n    plot(close, color = c)",
            "    //@version=4\n    study(\"My Script 12\", overlay=true)\n    plot(close, color=color.red, offset=-5)\n    plot(close, color=color.lime, offset=5)"
          ],
          "description": "The `plot` annotation function displays a series of values as a line on the chart. It has one mandatory parameter, a value of _series_ type. Pine’s automatic type conversions allow using any numeric value as an argument, which will be converted to a series type value (a constant value on every bar, plotted as a horizontal line). The function has many optional parameters to control the line's display style, such as `style`, `color`, `linewidth`, `transparency`, and `offset`.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v4/#fun_plot",
            "https://www.tradingview.com/pine-script-reference/v4/#fun_offset"
          ]
        },
        {
          "type": "Annotations",
          "heading": "Filling the background with fill",
          "remarks": "Please note that the `fill` annotation cannot be used with `plot` and `hline` arguments simultaneously. As a workaround you may replace `hline` calls with a `plot(<constant number>)`. You can set the fill color by using constants like `color=color.red` or `color=#ff001a`, as well as complex expressions like `color = close >= open ? color.green : color.red`.",
          "examples": [
            "//@version=4\nstudy(\"fill Example\")\np1 = plot(sin(high))\np2 = plot(cos(low))\np3 = plot(sin(close))\nfill(p1, p3, color=color.red)\nfill(p2, p3, color=color.blue)\nh1 = hline(0)\nh2 = hline(1.0)\nh3 = hline(0.5)\nh4 = hline(1.5)\nfill(h1, h2, color=color.yellow)\nfill(h3, h4, color=color.lime)",
            "//@version=4\nstudy(\"Fill example 2\")\nsrc = close, len = 10\nma = sma(src, len)\nosc = 100 * (ma - src) / ma\np = plot(osc)\n// NOTE: fill(p, hline(0)) wouldn't work, instead use this:\nfill(p, plot(0))",
            "//@version=4\nstudy(title=\"Colored fill\")\nline1=sma(close, 5)\nline2=sma(close, 20)\np1 = plot(line1)\np2 = plot(line2)\nfill(p1, p2, color = line1 > line2 ? color.green : color.red)"
          ],
          "description": "The fill annotation function lets you color the background between two plotted series or two horizontal lines created with `hline`.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v4/#fun_fill"
          ]
        },
        {
          "type": "Variables",
          "heading": "Bar states. Built-in variables barstate.*",
          "remarks": "All historical bars are considered _new_ bars. That is because of the fact that the script receives them in a sequential order from the oldest to the newer ones. For bars that update in realtime, a bar is considered new only at the opening tick of this bar.\n\nFootnote [1]: Variable `barstate.isconfirmed` returns the state of current chart symbol data only. It does not take into account any secondary symbol data requested with the `security` function.",
          "examples": [
            "//@version=4\nstudy(\"Bar States\", overlay = true)\nfirst = barstate.isfirst\nlast = barstate.islast\nhist = barstate.ishistory\nrt = barstate.isrealtime\nnew = barstate.isnew\nconf = barstate.isconfirmed\nt = new ? \"new\" : conf ? \"conf\" : \"intra-bar\"\nt := t + (hist ? \"\\nhist\" : rt ? \"\\nrt\" : \"\")\nt := t + (first ? \"\\nfirst\" : last ? \"\\nlast\" : \"\")\nlabel.new(bar_index, na, yloc=yloc.abovebar, text=t,\n          color=hist ? color.green : color.red)"
          ],
          "description": "A set of built-in variables of the `barstate` namespace allows users to define the bar states for which scripts actions are performed:\n\n- `barstate.isfirst` - `true` if the current bar is the first in the whole range of bars available, `false` otherwise.\n- `barstate.islast` - `true` if the current bar is the last in the whole range of bars available, `false` otherwise. This flag helps to detect _the last historical bar_.\n- `barstate.ishistory` - `true` if the current data update is a historical bar update, `false` otherwise (thus it is realtime).\n- `barstate.isrealtime` - `true` if the current data update is a real-time bar update, `false` otherwise (thus it is historical). Note that every realtime bar is also the _last_ one.\n- `barstate.isnew` - `true` if the current data update is the first (opening) update of a new bar, `false` otherwise.\n- `barstate.isconfirmed` - `true` if the current data update is the last (closing) update of the current bar, `false` otherwise. The next data update will be an opening update of a new bar[1].\n- `barstate.islastconfirmedhistory` - `true` if script is executing on the dataset’s last bar when market is closed, or script is executing on the bar immediately preceding the real-time bar, if market is open. Returns `false` otherwise.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v4/essential/bar-states-built-in-variables-barstate/#bar-states-built-in-variables-barstate"
          ]
        },
        {
          "type": "Concept",
          "heading": "Time series",
          "remarks": "Understanding time series is linked to Pine’s execution model and type system. Time series differ from arrays. The history-referencing operator `[]` is used to access past values. Even variables with a \"simple\" qualifier (whose value doesn't change bar-to-bar) are stored as time series, but accessing past values with `[]` yields a \"series\" qualified value. Pine's structure allows complex calculations across bars without explicit loops.",
          "examples": [
            "open",
            "open[1]",
            "ta.cum(close)",
            "ta.sma(high - low, 14)",
            "ta.barssince(ta.rising(high, 5))",
            "close > ta.highest(close, 10)[1]",
            "close > ta.highest(close[1], 10)",
            "plot(open)",
            "timeframe.period",
            "timeframe.period[10]"
          ],
          "description": "Time series are the fundamental structure Pine Script uses to store the successive values of a variable over time, where each value is tethered to a point in time (usually a chart bar). They are not a qualified type but are essential for processing data that changes over time, like bar prices (open, high, low, close).",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/execution-model/",
            "https://www.tradingview.com/pine-script-docs/language/type-system/",
            "https://www.tradingview.com/pine-script-reference/v6/#var_open",
            "https://www.tradingview.com/pine-script-reference/v6/#op_%5B%5D",
            "https://www.tradingview.com/pine-script-docs/language/arrays/#arrays",
            "https://www.tradingview.com/pine-script-reference/v6/#kw_for",
            "https://www.tradingview.com/pine-script-reference/v6/#var_close",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.cum",
            "https://www.tradingview.com/pine-script-reference/v6/#var_high",
            "https://www.tradingview.com/pine-script-reference/v6/#var_low",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.barssince",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.rising",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_plot",
            "https://www.tradingview.com/pine-script-reference/v6/#var_timeframe%7Bdot%7Dperiod"
          ]
        },
        {
          "type": "Variables",
          "heading": "Identifiers",
          "remarks": "",
          "examples": [
            "myVar\n_myVar\nmy123Var\nMAX_LEN\nmax_len"
          ],
          "description": "Identifiers are simply names for user-defined variables and functions.\nIdentifiers can be composed from lower and upper-case letters (from the\nEnglish alphabet), underscore `_` and numbers, however an identifier\ncannot begin with a number. Line and upper-case symbols differ (Pine is\ncase-sensitive).",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v3/language/comments",
            "https://www.tradingview.com/pine-script-docs/v3/language/lines-wrapping"
          ]
        },
        {
          "type": "Variable",
          "heading": "barstate.isfirst",
          "remarks": "It can be useful to initialize variables on the first bar only, e.g.:",
          "examples": [
            "// Declare array and set its values on the first bar only.\nFILL_COLOR = color.green\nvar fillColors = array.new_color(0)\nif barstate.isfirst\n    // Initialize the array elements with progressively lighter shades of the fill color.\n    array.push(fillColors, color.new(FILL_COLOR, 70))\n    array.push(fillColors, color.new(FILL_COLOR, 75))\n    array.push(fillColors, color.new(FILL_COLOR, 80))\n    array.push(fillColors, color.new(FILL_COLOR, 85))\n    array.push(fillColors, color.new(FILL_COLOR, 90))"
          ],
          "description": "[barstate.isfirst](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disfirst) is only `true` on the dataset’s first bar, i.e., when [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index) is zero.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disfirst",
            "https://www.tradingview.com/pine-script-reference/v6/#var_bar_index"
          ]
        },
        {
          "type": "Variable",
          "heading": "barstate.islast",
          "remarks": "It can be used to restrict the execution of code to the chart’s last bar, which is often useful when drawing lines, labels or tables. Here, we use it to determine when to update a label which we want to appear only on the last bar. We create the label only once and then update its properties using `label.set_*()` functions because it is more efficient:",
          "examples": [
            "//@version=6\nindicator(\"\", \"\", true)\n// Create label on the first bar only.\nvar label hiLabel = label.new(na, na, \"\")\n// Update the label's position and text on the last bar,\n// including on all realtime bar updates.\nif barstate.islast\n    label.set_xy(hiLabel, bar_index, high)\n    label.set_text(hiLabel, str.tostring(high, format.mintick))"
          ],
          "description": "[barstate.islast](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Dislast) is `true` if the current bar is the last one on the chart, whether that bar is a realtime bar or not.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Dislast"
          ]
        },
        {
          "type": "Variable",
          "heading": "barstate.ishistory",
          "remarks": "It can never be `true` on a bar when [barstate.isrealtime](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disrealtime) is also `true`, and it does not become `true` on a realtime bar’s closing update, when [barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disconfirmed) becomes `true`. On closed markets, it can be `true` on the same bar where [barstate.islast](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Dislast) is also `true`.",
          "examples": [],
          "description": "[barstate.ishistory](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Dishistory) is `true` on all historical bars.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Dishistory",
            "https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disrealtime",
            "https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disconfirmed",
            "https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Dislast"
          ]
        },
        {
          "type": "Variable",
          "heading": "barstate.isrealtime",
          "remarks": "Note that [barstate.islast](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Dislast) is also `true` on all realtime bars.",
          "examples": [],
          "description": "[barstate.isrealtime](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disrealtime) is `true` if the current data update is a real-time bar update, `false` otherwise (thus it is historical).",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disrealtime",
            "https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Dislast"
          ]
        },
        {
          "type": "Variable",
          "heading": "barstate.isnew",
          "remarks": "[barstate.isnew](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disnew) can be useful to reset [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip) variables when a new realtime bar comes in. The following code will reset `updateNo` to 1 on all historical bars and at the beginning of each realtime bar. It calculates the number of realtime updates during each realtime bar:",
          "examples": [
            "//@version=6\nindicator(\"\")\nupdateNo() =>\n    varip int updateNo = na\n    if barstate.isnew\n        updateNo := 1\n    else\n        updateNo += 1\nplot(updateNo())"
          ],
          "description": "[barstate.isnew](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disnew) is `true` on all historical bars and on the realtime bar’s first (opening) update.\n\nAll historical bars are considered _new_ bars because the Pine Script® runtime executes your script on each bar sequentially, from the chart’s first bar in time, to the last. Each historical bar is thus _discovered_ by your script as it executes, bar to bar.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disnew",
            "https://www.tradingview.com/pine-script-reference/v6/#kw_varip"
          ]
        },
        {
          "type": "Variable",
          "heading": "barstate.isconfirmed",
          "remarks": "It can be useful to avoid repainting by requiring the realtime bar to be closed before a condition can become `true`. We use it here to hold plotting of our RSI until the realtime bar closes and becomes an elapsed realtime bar. It will plot on historical bars because [barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disconfirmed) is always `true` on them:\n\n[barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disconfirmed) will not work when used in a [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request%7Bdot%7Dsecurity) call.",
          "examples": [
            "//@version=6\nindicator(\"\")\nmyRSI = ta.rsi(close, 20)\nplot(barstate.isconfirmed ? myRSI : na)"
          ],
          "description": "[barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disconfirmed) is `true` on all historical bars and on the last (closing) update of a realtime bar.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Disconfirmed",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_request%7Bdot%7Dsecurity"
          ]
        },
        {
          "type": "Variable",
          "heading": "barstate.islastconfirmedhistory",
          "remarks": "It can be used to detect the first realtime bar with `barstate.islastconfirmedhistory[1]`, or to postpone server-intensive calculations until the last historical bar, which would otherwise be undetectable on open markets.",
          "examples": [],
          "description": "[barstate.islastconfirmedhistory](https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Dislastconfirmedhistory) is `true` if the script is executing on the dataset’s last bar when the market is closed, or on the bar immediately preceding the realtime bar if the market is open.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_barstate%7Bdot%7Dislastconfirmedhistory"
          ]
        },
        {
          "type": "Type",
          "heading": "Tuples",
          "remarks": "Using a tuple with `request.security()` is more efficient than making multiple separate calls.",
          "examples": [
            "// Using a tuple to request several values efficiently:\n[o, h, l, c] = request.security(syminfo.tickerid, \"D\", [open, high, low, close])"
          ],
          "description": "A tuple in Pine Script is a list of values that is returned by a function, method, or local block. Unlike in other languages, tuples in Pine serve no other function. Tuples do not have names and cannot be assigned to variables. Apart from the fact that the values are requested and returned together, the values have no relation to each other. To define a tuple, enclose a comma-separated list of values in square brackets.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/type-system/#tuples",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_request.security"
          ]
        },
        {
          "type": "Type",
          "heading": "Arrays",
          "remarks": "Arrays are versatile data structures useful for storing and manipulating collections of data.",
          "examples": [
            "//@version=6\nindicator(\"Array example\")\n// Declare an array with 5 `na` values on the first bar.\nvar array<float> pricesArray = array.new<float>(5)\n// On each bar, add a new value to the end of the array and remove the first (oldest) element.\narray.push(pricesArray, close)\narray.shift(pricesArray)\n// Display the array and its contents in a table.\nvar table displayTable = table.new(position.middle_right, 1, 1)\nif barstate.islast\ntable.cell(displayTable, 0, 0, str.tostring(pricesArray), text_color = chart.fg_color)"
          ],
          "description": "Arrays store multiple values of the same type in a single variable. Each element in an array can be efficiently accessed by its index. Arrays can contain an arbitrary number of elements. Scripts can loop through arrays and use built-in functions for various operations. Arrays can be created with `array.new<type>()` or `array.from()`.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/arrays/",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_array.new%3Ctype%3E",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_array.from"
          ]
        },
        {
          "type": "Type",
          "heading": "Matrices",
          "remarks": "Matrices are useful for modeling complex systems, solving mathematical problems, and improving algorithm performance.",
          "examples": [
            "//@version=6\nindicator(\"Matrix sum example\")\n\n//@variable An empty matrix of type \"float\".\nm = matrix.new<float>()\n\n// Add rows to the matrix containing data.\nm.add_row(0, array.from(1, 2, 3))\nm.add_row(1, array.from(0, 4, 2))\nm.add_row(2, array.from(3, 1, 2))\n\nvar table displayTable = table.new(position.middle_right, 5, 2)\nif barstate.islast\n    matrix<float> t = m.transpose()\n    table.cell(displayTable, 0, 0, \"A\", text_color = chart.fg_color)\n    table.cell(displayTable, 0, 1, str.tostring(m), text_color = chart.fg_color)\n    table.cell(displayTable, 1, 1, \"+\", text_color = chart.fg_color)\n    table.cell(displayTable, 2, 0, \"Aᵀ\", text_color = chart.fg_color)\n    table.cell(displayTable, 2, 1, str.tostring(t), text_color = chart.fg_color)\n    table.cell(displayTable, 3, 1, \"=\", text_color = chart.fg_color)\n    table.cell(displayTable, 4, 0, \"A + Aᵀ\", text_color = color.green)\n    table.cell(displayTable, 4, 1, str.tostring(matrix.sum(m, t)), text_color = color.green)"
          ],
          "description": "A matrix is a two-dimensional array, made of rows and columns, like a spreadsheet. Matrices, like arrays, store values of the same built-in or user-defined type. Matrices have many built-in functions available to organize and manipulate their data.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/matrices/",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#types",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_matrix.sum",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_matrix.transpose"
          ]
        },
        {
          "type": "Type",
          "heading": "Objects",
          "remarks": "Objects allow grouping related data of potentially different types into a single structure.",
          "examples": [
            "//@version=6\nindicator(\"Object example\", overlay = true)\n\n// Create the pivot type with 3 fields: the x coordinate, the y coordinate, and a formatted time string.\ntype pivot\n    int x\n    float y\n    string pivotTime\n// Check for new pivots. `ta.pivotHigh` returns the price of the pivot.\nfloat pivFound = ta.pivothigh(10, 10)\n// When a pivot is found, create a new pivot object and generate a label using the values from its fields.\nif not na(pivFound)\n    pivot pivotObject = pivot.new(bar_index - 10, pivFound, str.format_time(time[10], \"yyyy-MM-dd HH:mm\"))\n    label.new(pivotObject.x, pivotObject.y, pivotObject.pivotTime, textcolor = chart.fg_color)"
          ],
          "description": "Pine Script objects are containers that group together multiple fields into one logical unit. Objects are instances of user-defined types (UDTs), which are similar to structs. UDTs define the rules for what an object can contain. Scripts first create a UDT using the `type` keyword and then create objects using the UDT’s built-in `new()` method. UDTs are composite types; they contain an arbitrary number of fields that can be of any type, including other UDTs.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/objects/",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types",
            "https://www.tradingview.com/pine-script-reference/v6/#kw_type"
          ]
        },
        {
          "type": "Type",
          "heading": "Maps",
          "remarks": "Maps are useful when accessing data directly by a key without searching through each element, potentially offering better performance than arrays for certain tasks.",
          "examples": [
            "//@version=6\nindicator(\"Earnings map\", overlay = true)\n// Get the earnings value if present. We use `barmerge.gaps_on` to return `na` unless earnings occurred.\nfloat earnings = request.earnings(syminfo.tickerid, earnings.actual, barmerge.gaps_on)\n// Declare a map object for storing earnings dates and values.\nvar map<string, float> earningsMap = map.new<string, float>()\n// If `request.security()` returned data, add an entry to the map with the date as the key and earnings as the value.\nif not na(earnings)\n    map.put(earningsMap, str.format_time(time, \"yyyy-MM-dd\"), earnings)\n// On the last historical bar, loop through the map in the insertion order, writing the key-value pairs to the logs.\nif barstate.islastconfirmedhistory\n    string logText = \"\\n\"\n    for [key, value] in earningsMap\n        logText += str.format(\"{0}: {1}\\n\", key, value)\n    log.info(logText)"
          ],
          "description": "Maps in Pine Script are similar to dictionaries in other languages. They store elements as key-value pairs, where each key is unique. Scripts can access a particular value by looking up its associated key. Keys must be of a single type, and values must be of a single type.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/maps/#maps",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_request.earnings",
            "https://www.tradingview.com/pine-script-reference/v6/#const_barmerge.gaps_on",
            "https://www.tradingview.com/pine-script-docs/language/maps/#looping-through-a-map"
          ]
        },
        {
          "type": "Type",
          "heading": "What’s the difference between a series and an array?",
          "remarks": "Series are fundamental to Pine Script's time-series based execution model. Arrays are more flexible, general-purpose collections created and manipulated by script logic, not tied inherently to the bar sequence.",
          "examples": [],
          "description": "In Pine Script, “series” variables are calculated on each bar. Historical values cannot change. Series values can change during the realtime bar, but become fixed when the bar closes. These fixed values are automatically indexed by bar time. Scripts can access values from previous bars using the `[]` history-referencing operator.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/type-system/#series",
            "https://www.tradingview.com/pine-script-docs/language/operators/#--history-referencing-operator",
            "https://www.tradingview.com/pine-script-docs/language/arrays/",
            "https://www.tradingview.com/pine-script-docs/language/time-series/",
            "https://www.tradingview.com/pine-script-docs/language/execution-model/"
          ]
        },
        {
          "type": "Operator",
          "heading": "History-Referencing Operator",
          "remarks": "This operator is specific to 'series' variables and allows accessing historical data points within the time series.",
          "examples": [
            "// Accessing previous close price:\nprevClose = close[1]"
          ],
          "description": "The `[]` history-referencing operator is used with 'series' variables to access their values from previous bars. For example, `close[1]` refers to the closing price of the previous bar.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/operators/#--history-referencing-operator"
          ]
        },
        {
          "type": "Keyword",
          "heading": "What’s the difference between an array declared with or without ​ `var` ​?",
          "remarks": "Use `var` for arrays that need to accumulate data or maintain state across bars. Use non-`var` arrays for calculations specific to the current bar.",
          "examples": [
            "//@version=6\nindicator(\"Using `var` with arrays\")\n//@variable An array that initializes on every bar.\na = array.new<float>()\narray.push(a, close)\n//@variable An array that expands its size by 1 on each bar.\nvar b = array.new<float>(0)\narray.push(b, close)\n// ... (table display code omitted for brevity)"
          ],
          "description": "Using the `var` keyword when declaring an array variable initializes it only once, during the first iteration on the first chart bar. This allows the array to persist its contents across bars (persistent array). Arrays declared without `var` are reinitialized on every new bar (non-persistent array).",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#op_var",
            "https://www.tradingview.com/pine-script-docs/language/variable-declarations/#declaration-modes",
            "https://www.tradingview.com/pine-script-docs/language/arrays/#using-var-and-varip-keywords"
          ]
        },
        {
          "type": "Keyword",
          "heading": "How can I perform operations on all elements in an array?",
          "remarks": "This is the standard way to process each element within an array in Pine Script.",
          "examples": [
            "// Simple form:\nfor eachLine in id\n    eachLine.set_x2(bar_index)\n\n// Two-argument form:\nfor [i, eachValue] in valuesArray\n    if eachValue > 0\n        array.set(isPos, i, true)"
          ],
          "description": "The `for...in` structure iterates through the elements of an array. The simple form `for element in array` retrieves each element. The two-argument form `for [index, element] in array` retrieves both the element and its index.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#kw_for...in",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#tuples"
          ]
        },
        {
          "type": "Keyword",
          "heading": "Objects",
          "remarks": "UDTs allow creating complex data structures similar to structs or classes in other languages.",
          "examples": [
            "// Define the pivot type\ntype pivot\n    int x\n    float y\n    string pivotTime"
          ],
          "description": "The `type` keyword is used to define a user-defined type (UDT), which serves as a template for creating objects.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#kw_type",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types"
          ]
        },
        {
          "type": "Syntax",
          "heading": "Declaring a map",
          "remarks": "Requires the `map` keyword and a type template `<keyType, valueType>` when assigning `na` initially. Type declaration can often be inferred by the compiler when assigning a map instance directly. Maps can hold up to 50,000 key-value pairs (100,000 total elements).",
          "examples": [
            "map<string, float> myMap = na",
            "myMap = map.new<string, float>()"
          ],
          "description": "Explains the syntax for declaring map variables in Pine Script. Maps store key-value pairs and are unordered collections.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/type-system/#type-templates",
            "https://www.tradingview.com/pine-script-reference/v6/#type_map",
            "https://www.tradingview.com/pine-script-reference/v6/#type_string",
            "https://www.tradingview.com/pine-script-reference/v6/#type_float"
          ]
        },
        {
          "type": "Keyword",
          "heading": "Using `var` and `varip` keywords",
          "remarks": "Variables declared using `var` or `varip` point to the same map instance on each script iteration until explicitly reassigned.",
          "examples": [
            "//@version=6\nindicator(\"var map demo\")\n//@variable A map associating color values with string keys.\nvar colorMap = map.new<string, color>()\n// Put `<string, color>` pairs into `colorMap` on the first bar.\nif bar_index == 0\n    colorMap.put(\"Bull\", color.green)\n    colorMap.put(\"Bear\", color.red)\n    colorMap.put(\"Neutral\", color.gray)\n//@variable The 14-bar RSI of `close`.\nfloat oscillator = ta.rsi(close, 14)\n//@variable The color of the `oscillator`.\ncolor oscColor = switch\n    oscillator > 50 => colorMap.get(\"Bull\")\n    oscillator < 50 => colorMap.get(\"Bear\")\n    =>               colorMap.get(\"Neutral\")\n// Plot the `oscillator` using the `oscColor` from our `colorMap`.\nplot(oscillator, \"Histogram\", oscColor, 2, plot.style_histogram, histbase = 50)\nplot(oscillator, \"Line\", oscColor, 3)"
          ],
          "description": "Keywords used to declare map variables only on the first chart bar, making the variable retain its state across subsequent bars unless explicitly reassigned.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#kw_var",
            "https://www.tradingview.com/pine-script-reference/v6/#kw_varip",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.put",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.get"
          ]
        },
        {
          "type": "Function",
          "heading": "map.put()",
          "remarks": "Replacing an existing key-value pair does not change the internal insertion order of the keys. When putting values of special types (line, label, UDT, etc.), the map stores a reference to the object, not a copy. Modifying the object through the map affects the original object.",
          "examples": [
            "data.put(\"Rising\", bar_index)",
            "data.put(\"Falling\", bar_index)",
            "data.put(\"Difference\", data.get(\"Rising\") - data.get(\"Falling\"))",
            "myMap.put(\"A\", myData)",
            "myMap.put(\"B\", myData)"
          ],
          "description": "Puts a new key-value pair into a specified map. If the key already exists, the existing pair is replaced with the new one.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.put",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.keys",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.get",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.contains",
            "https://www.tradingview.com/pine-script-reference/v6/#var_na",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types",
            "https://www.tradingview.com/pine-script-docs/language/objects/#copying-objects"
          ]
        },
        {
          "type": "Function",
          "heading": "map.get()",
          "remarks": "Returns the associated value if the key exists in the map; otherwise, it returns `na`.",
          "examples": [
            "colorMap.get(\"Bull\")",
            "data.get(\"Rising\")",
            "data.get(\"Falling\")",
            "data.get(\"Difference\")",
            "myMap.get(\"A\")",
            "myMap.get(\"B\")"
          ],
          "description": "Retrieves the value associated with a specified key from a map.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.get",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.contains",
            "https://www.tradingview.com/pine-script-reference/v6/#var_na"
          ]
        },
        {
          "type": "Function",
          "heading": "map.keys()",
          "remarks": "Pine Script internally maintains the insertion order of key-value pairs. Modifying the returned array does not affect the original map. Replacing key-value pairs does not change the insertion order unless the key was previously removed.",
          "examples": [
            "array<string> keys = m.keys()"
          ],
          "description": "Retrieves all keys from a map as a new array object. The keys in the array are ordered based on their insertion order into the map.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.keys",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.values",
            "https://www.tradingview.com/pine-script-reference/v6/#type_array",
            "https://www.tradingview.com/pine-script-docs/language/maps/#removing-key-value-pairs"
          ]
        },
        {
          "type": "Function",
          "heading": "map.values()",
          "remarks": "The order of values in the returned array matches the order of keys returned by `map.keys()`. Modifying the returned array does not affect the original map.",
          "examples": [
            "array<float> values = m.values()"
          ],
          "description": "Retrieves all values from a map as a new array object. The values in the array are ordered corresponding to the insertion order of their keys.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.values",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.keys",
            "https://www.tradingview.com/pine-script-reference/v6/#type_array"
          ]
        },
        {
          "type": "Function",
          "heading": "map.contains()",
          "remarks": "Returns `true` if the key exists in the map, `false` otherwise. It's a convenient alternative to using `array.includes()` on the result of `map.keys()`.",
          "examples": [
            "if m.contains(key)\n    mappedKeys.push(key)"
          ],
          "description": "Checks if a map contains a specific key.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.contains",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_array.includes",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.keys",
            "https://www.tradingview.com/pine-script-reference/v6/#type_array"
          ]
        },
        {
          "type": "Function",
          "heading": "map.remove()",
          "remarks": "Returns the value that was associated with the removed key. If the key was not found in the map, it returns `na` and the map remains unchanged. The insertion order of the remaining pairs is preserved.",
          "examples": [
            "m.remove(key)"
          ],
          "description": "Removes a specific key-value pair from a map using the provided key.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.remove",
            "https://www.tradingview.com/pine-script-docs/language/maps/#mapcontains",
            "https://www.tradingview.com/pine-script-reference/v6/#var_na",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.clear"
          ]
        },
        {
          "type": "Function",
          "heading": "map.clear()",
          "remarks": "This function modifies the map in place.",
          "examples": [
            "m.clear()"
          ],
          "description": "Removes all key-value pairs from a map, making it empty.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.clear",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.remove"
          ]
        },
        {
          "type": "Function",
          "heading": "map.put_all()",
          "remarks": "Pairs are added respecting their insertion order from `id2`. If any keys from `id2` already exist in `id1`, the corresponding pairs in `id1` are replaced, but their original insertion order within `id1` is maintained.",
          "examples": [
            "mapA.put_all(mapB)"
          ],
          "description": "Puts all key-value pairs from a second map (`id2`) into a primary map (`id1`).",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.put_all",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.put"
          ]
        },
        {
          "type": "Keyword",
          "heading": "for...in loop (for maps)",
          "remarks": "This is the recommended method for looping through maps. It iterates based on the insertion order of the pairs, returning a tuple `[key, value]` for each pair on every iteration.",
          "examples": [
            "for [key, value] in thisMap"
          ],
          "description": "A `for...in` loop structure used to iterate directly over the key-value pairs of a map.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.keys",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.get",
            "https://www.tradingview.com/pine-script-reference/v6/#type_table"
          ]
        },
        {
          "type": "Function",
          "heading": "map.copy()",
          "remarks": "Modifications to the shallow copy (like adding or removing pairs) do not affect the original map. However, if the map values are of special types or UDTs, both the original map and the shallow copy will reference the *same* objects. Changes to these objects via one map will be reflected when accessing them through the other map.",
          "examples": [
            "mCopy = m.copy()"
          ],
          "description": "Creates a shallow copy of a map.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.copy",
            "https://www.tradingview.com/pine-script-docs/language/maps/#deep-copies"
          ]
        },
        {
          "type": "Concept",
          "heading": "Deep copies",
          "remarks": "Necessary when a map contains values of special types or UDTs to ensure that modifications to objects in the copied map do not affect the objects referenced by the original map. Typically implemented by creating a new map and iterating through the original, putting copies of each value into the new map.",
          "examples": [
            "//@function Returns a deep copy of `this` map.\nmethod deepCopy(map<string, label> this) =>\n    //@variable A deep copy of `this` map.\n    result = map.new<string, label>()\n    // Add key-value pairs with copies of each `value` to the `result`.\n    for [key, value] in this\n        result.put(key, value.copy())\n    result //Return the `result`.\n//@variable A deep copy of the `original` map.\nmap<string, label> deep = original.deepCopy()"
          ],
          "description": "The concept of creating a completely independent copy of a map, including copies of any objects (like UDTs or special types) stored as values.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/maps/#shallow-copies",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_map.new%3Ctype,type%3E"
          ]
        },
        {
          "type": "Operator",
          "heading": "History-Referencing Operator [] (for maps)",
          "remarks": "Map variables, like other Pine Script collections, maintain a history across chart bars. This operator retrieves the map's state as it was `n` bars ago.",
          "examples": [
            "map<int, float> previous = globalData[1]"
          ],
          "description": "The history-referencing operator `[]` allows accessing previous instances of a map variable from past bars.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#op_%5B%5D",
            "https://www.tradingview.com/pine-script-docs/language/user-defined-functions/",
            "https://www.tradingview.com/pine-script-docs/language/methods/",
            "https://www.tradingview.com/pine-script-docs/language/conditional-structures/"
          ]
        },
        {
          "type": "Type",
          "heading": "map<keyType, valueType>",
          "remarks": "`<keyType>` can be any fundamental type (int, float, bool, string, color) or enum type. `<valueType>` can be any available type, including UDTs, but not other collections (maps, arrays, matrices) directly. This explicit type declaration is mandatory when initializing a map variable with `na`.",
          "examples": [
            "map<string, float>",
            "map<string, color>",
            "map<int, string>",
            "map<string, ChartData>",
            "map<string, label>",
            "map<int, float>",
            "map<string, Wrapper>"
          ],
          "description": "The type declaration syntax for maps, specifying the data types for keys and values using a type template.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/type-system/#type-templates",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#types",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#enum-types",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#collections",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types",
            "https://www.tradingview.com/pine-script-reference/v6/#var_na"
          ]
        },
        {
          "type": "Variables",
          "heading": "How can I prevent the “Bar index value of the ​ `x` ​ argument is too far from the current bar index. Try using ​ `time` ​ instead” and “Objects positioned using xloc.bar_index cannot be drawn further than X bars into the future” errors?",
          "remarks": "By default, drawings use `xloc.bar_index`. Using time-based values without `xloc = xloc.bar_time` treats the timestamp as a bar index, likely exceeding limits.",
          "examples": [],
          "description": "Discusses errors related to drawing objects too far from the current bar and recommends using `xloc.bar_time` with `time` values instead of the default `xloc.bar_index` with `bar_index` values to avoid these errors. Emphasizes specifying `xloc = xloc.bar_time` when using time-based coordinates.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/concepts/lines-and-boxes/#lines",
            "https://www.tradingview.com/pine-script-docs/concepts/text-and-shapes/#labels",
            "https://www.tradingview.com/pine-script-docs/concepts/lines-and-boxes/#boxes",
            "https://www.tradingview.com/pine-script-reference/v6/#var_xloc.bar_time",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_time",
            "https://www.tradingview.com/pine-script-reference/v6/#var_bar_index"
          ]
        },
        {
          "type": "Variables",
          "heading": "How can I update the right side of all lines or boxes?",
          "remarks": "Scripts can access all drawn instances of a type using the `<drawingNamespace>.all` built-in variable (e.g., `line.all`).",
          "examples": [
            "//@version=6\nindicator(\"Update x2 demo\", \"\", true)\nint activeLevelsInput = input.int(10, \"Number of levels\")\nint pivotLegsInput    = input.int(5,  \"Pivot length\")\n// Save pivot prices.\nfloat pHi = ta.pivothigh(pivotLegsInput, pivotLegsInput)\n// Initialize an array for lines on the first bar, sized to match the number of levels to track.\nvar array<line> pivotLines = array.new<line>(activeLevelsInput)\n// Check for a pivot. Add a new line to the array. Remove and delete the oldest line.\nif not na(pHi)\n    line newPivotLine = line.new(bar_index[pivotLegsInput], pHi, bar_index, pHi)\n    pivotLines.push(newPivotLine)\n    pivotLines.shift().delete()\n// Update all line x2 values.\nif barstate.islast\n    for eachLine in pivotLines\n        eachLine.set_x2(bar_index)",
            "//@version=6\nindicator(\"Update x2 demo\", \"\", true)\nint activeLevelsInput = input.int(10, \"Number of levels\")\nint pivotLegsInput    = input.int(5,  \"Pivot length\")\n// Save pivot prices.\nfloat pHi = ta.pivothigh(pivotLegsInput, pivotLegsInput)\n// Check for a pivot. Delete the oldest line if the array is over the \"Number of levels\" limit.\nif not na(pHi)\n    line newPivotLine = line.new(bar_index[pivotLegsInput], pHi, bar_index, pHi)\n    if line.all.size() > activeLevelsInput\n        line.all.first().delete()\n// Update all line x2 values.\nif barstate.islast\n    for eachLine in line.all\n        eachLine.set_x2(bar_index)"
          ],
          "description": "Explains how to update properties of all instances of a drawing type (like lines or boxes) by iterating over either a custom array storing the drawing IDs or the built-in `.all` arrays (e.g., `line.all`, `label.all`). Demonstrates updating the `x2` coordinate of lines using `line.set_x2()` within a `for...in` loop.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#op_for...in",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_line.set_x2",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_box.set_right",
            "https://www.tradingview.com/pine-script-reference/v6/#var_label.all",
            "https://www.tradingview.com/pine-script-reference/v6/#var_polyline.all",
            "https://www.tradingview.com/pine-script-reference/v6/#var_line.all"
          ]
        },
        {
          "type": "Variables",
          "heading": "How to avoid repainting when _not_ using the ​ `request.security()` ​ function?",
          "remarks": "Intra-bar repainting (due to changing close, high, low, volume) is usually not deceptive.",
          "examples": [],
          "description": "Discusses repainting caused by scripts behaving differently on historical vs. realtime bars, often due to `request.security()`, or intra-bar changes in `volume`, `close`, `high`, `low`. Suggests using confirmed values (previous bar's data), setting alerts on bar close, or using `open` instead of `close` to mitigate non-`request.security()` related repainting.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/concepts/repainting/",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_request.security",
            "https://www.tradingview.com/pine-script-reference/v6/#var_volume",
            "https://www.tradingview.com/pine-script-reference/v6/#var_close",
            "https://www.tradingview.com/pine-script-reference/v6/#var_high",
            "https://www.tradingview.com/pine-script-reference/v6/#var_low",
            "https://www.tradingview.com/pine-script-docs/faq/alerts/#why-is-my-alert-firing-at-the-wrong-time",
            "https://www.tradingview.com/pine-script-reference/v6/#var_open",
            "https://www.tradingview.com/script/s8kWs84i-How-to-avoid-repainting-when-NOT-using-security/"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I trigger a condition n bars after it last occurred?",
          "remarks": "",
          "examples": [
            "//@version=6\nindicator(\"`barssince` demo\", overlay = true)\nint  lengthInput = input.int(3, \"Length\")\nbool cond = close > open and close[1] > open[1]\nint  count = ta.barssince(cond[1]) + 1\nbool trigger = cond and count > lengthInput\nplot(cond ? 0 : count, \"Count\", display = display.data_window)\nplotchar(cond)\nplotchar(trigger, \"\", \"O\", color = color.red)"
          ],
          "description": "Explains how to use the `ta.barssince()` function to determine the number of bars that have passed since a specific condition was last true. This allows triggering another condition only after a certain number of bars (`n`) have elapsed since the initial condition occurred.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.barssince",
            "https://www.tradingview.com/pine-script-reference/v6/#var_close",
            "https://www.tradingview.com/pine-script-reference/v6/#var_open"
          ]
        },
        {
          "type": "Variables",
          "heading": "How can my script identify what chart type is active?",
          "remarks": "",
          "examples": [
            "//@version=6\nindicator(\"Chart type\", \"\", true)\nchartTypeToString() =>\n    string result = switch\n        chart.is_standard   => \"Standard\"\n        chart.is_heikinashi => \"Heikin-Ashi\"\n        chart.is_kagi       => \"Kagi\"\n        chart.is_linebreak  => \"Line Break\"\n        chart.is_pnf        => \"Point and Figure\"\n        chart.is_range      => \"Range\"\n        chart.is_renko      => \"Renko\"\nif barstate.islastconfirmedhistory\n    var table display = table.new(position.bottom_right, 1, 1, bgcolor = chart.fg_color)\n    table.cell(display, 0, 0, str.format(\"Chart type: {0}\", chartTypeToString()), text_color = chart.bg_color)"
          ],
          "description": "Demonstrates how to identify the active chart type (Standard, Heikin-Ashi, Kagi, etc.) using boolean built-in variables within the `chart.*` namespace (e.g., `chart.is_standard`, `chart.is_heikinashi`). Provides a function `chartTypeToString()` that uses a `switch` statement to return the name of the current chart type.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/built-ins/"
          ]
        },
        {
          "type": "Variables",
          "heading": "How can I plot the highest and lowest visible candle values?",
          "remarks": "Values derived from visible chart variables can change during runtime. Calculations should ideally occur outside local blocks like `if barstate.islast`, and drawing deferred to the last bar to reflect the entire visible range accurately.",
          "examples": [
            "//@version=6\nindicator(\"Chart's visible high/low\", \"\", true)\nimport PineCoders/VisibleChart/4 as PCvc\n// Calculate the chart's visible high and low prices and their corresponding times.\nint x1 = PCvc.highBarTime()\nint x2 = PCvc.lowBarTime()\nfloat chartHi = PCvc.high()\nfloat chartLo = PCvc.low()\n// Draw lines and labels on the last bar.\nif barstate.islast\n    line.new(x1, chartHi, x2, chartHi, xloc.bar_time, extend.both, color.lime)\n    line.new(x1, chartLo, x2, chartLo, xloc.bar_time, extend.both, color.fuchsia)\n    string hiTxt = str.format(\"{0}\\n{1}\", str.tostring(chartHi, format.mintick), str.format_time(x1, format = \"dd/MM/yy @ HH:mm\"))\n    string loTxt = str.format(\"{0}\\n{1}\", str.tostring(chartLo, format.mintick), str.format_time(x2, format = \"dd/MM/yy @ HH:mm\"))\n    label.new(x1, chartHi, hiTxt, xloc.bar_time, yloc.price, color.new(color.lime, 80),    label.style_label_down, color.lime)\n    label.new(x2, chartLo, loTxt, xloc.bar_time, yloc.price, color.new(color.fuchsia, 80), label.style_label_up,   color.fuchsia)"
          ],
          "description": "Explains how to find the highest high and lowest low within the visible range of bars on the chart using the `chart.left_visible_bar_time` and `chart.right_visible_bar_time` built-in variables. Recommends using the `VisibleChart` library by PineCoders for functions like `high()` and `low()` that dynamically calculate these values.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_high",
            "https://www.tradingview.com/pine-script-reference/v6/#var_low",
            "https://www.tradingview.com/pine-script-reference/v6/#var_chart.left_visible_bar_time",
            "https://www.tradingview.com/pine-script-reference/v6/#var_chart.right_visible_bar_time",
            "https://www.tradingview.com/script/j7vCseM2-VisibleChart/",
            "https://www.tradingview.com/u/PineCoders/",
            "https://www.tradingview.com/pine-script-docs/concepts/lines-and-boxes/#lines",
            "https://www.tradingview.com/pine-script-docs/concepts/text-and-shapes/#labels",
            "https://www.tradingview.com/pine-script-reference/v6/#var_barstate.islast",
            "https://www.tradingview.com/pine-script-docs/faq/programming/#what-does-scope-mean"
          ]
        },
        {
          "type": "Functions",
          "heading": "How to remember the last time a condition occurred?",
          "remarks": "Using the history-referencing operator `[]` with the bar offset allows retrieving past values. Storing the value directly with `var` is more efficient and avoids potential runtime errors from large history references.",
          "examples": [
            "//@version=6\nindicator(\"Track distance from condition\", \"\", true)\n// Plot the high/low from the bar where a condition occurred the last time.\n// Conditions\nbool upBar = close > open\nbool dnBar = close < open\nbool up3Bars = dnBar and upBar[1] and upBar[2] and upBar[3]\nbool dn3Bars = upBar and dnBar[1] and dnBar[2] and dn3Bars\ndisplay = display.data_window\n// Method 1: Using \"ta.barssince()\".\nplot(high[ta.barssince(up3Bars)], color = color.new(color.blue, 80), linewidth = 16)\nplot(low[ta.barssince(dn3Bars)],  color = color.new(color.red,  80), linewidth = 16)\nplot(ta.barssince(up3Bars), \"1. ta.barssince(up3Bars)\", display = display)\nplot(ta.barssince(dn3Bars), \"1. ta.barssince(dn3Bars)\", display = display)\n// Method 2: Manually replicating the functionality of the \"ta.barssince()\" function.\nvar int barsFromUp = na\nvar int barsFromDn = na\nbarsFromUp := up3Bars ? 0 : barsFromUp + 1\nbarsFromDn := dn3Bars ? 0 : barsFromDn + 1\nplot(high[barsFromUp], color = color.blue, linewidth = 3)\nplot(low[barsFromDn],  color = color.red,  linewidth = 3)\nplot(barsFromUp, \"3. barsFromUp\", display = display)\nplot(barsFromDn, \"3. barsFromDn\", display = display)\n// Method 3: Storing the `bar_index` value when a condition is met.\nvar int barWhenUp = na\nvar int barWhenDn = na\nif up3Bars\n    barWhenUp := bar_index\nif dn3Bars\n    barWhenDn := bar_index\nplot(high[bar_index - barWhenUp], color = color.new(color.blue, 70), linewidth = 8)\nplot(low[bar_index  - barWhenDn], color = color.new(color.red,  70), linewidth = 8)\nplot(bar_index - barWhenUp, \"2. bar_index - barWhenUp\", display = display)\nplot(bar_index - barWhenDn, \"2. bar_index - barWhenDn\", display = display)\n// Method 4: Storing the value when a condition is met.\nvar float highWhenUp = na\nvar float lowWhenDn  = na\nif up3Bars\n    highWhenUp := high\nif dn3Bars\n    lowWhenDn  := low\nplot(highWhenUp, color = color.new(color.white, 70), linewidth = 1)\nplot(lowWhenDn,  color = color.new(color.white, 70), linewidth = 1)"
          ],
          "description": "Presents multiple methods to track the number of bars since a condition last occurred and retrieve values from that bar:\n1. Using the built-in `ta.barssince()` function (simplest).\n2. Manually counting bars since the condition, resetting the count when the condition occurs.\n3. Storing the `bar_index` when the condition occurs and calculating the difference from the current `bar_index`.\n4. Directly storing the required value (e.g., `high` or `low`) in a `var` variable when the condition occurs (most efficient if only the value is needed).",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.barssince",
            "https://www.tradingview.com/pine-script-reference/v6/#var_bar_index",
            "https://www.tradingview.com/pine-script-reference/v6/#op_%5B%5D",
            "https://www.tradingview.com/pine-script-reference/v6/#var_close",
            "https://www.tradingview.com/pine-script-docs/error-messages/#pine-script-cannot-determine-the-referencing-length-of-a-series-try-using-max_bars_back-in-the-indicator-or-strategy-function"
          ]
        },
        {
          "type": "Functions",
          "heading": "Using ​ `timeframe.change()` ​",
          "remarks": "This method relies on the chart's timeframe transitions and doesn't adjust for session times. Intraday `open` might differ from the 1D candle `open` for some markets due to differences in data aggregation.",
          "examples": [
            "//@version=6\nindicator(\"Previous and current day open using `timeframe.change()`\", \"\", true)\nbool newDay = timeframe.change(\"1D\")\nvar float yesterdayOpen = na\nvar float todayOpen     = na\nif newDay\n    yesterdayOpen := todayOpen  // We reassign this value first\n    todayOpen     := open  // and then store today's open\nplot(yesterdayOpen, \"Yesterday's Open\", newDay ? na : color.red, 2, plot.style_line)\nplot(todayOpen, \"Today's Open\", newDay ? na : color.green, 2, plot.style_line)\nbgcolor(newDay ? color.new(color.gray, 80) : na)"
          ],
          "description": "Demonstrates using the `timeframe.change()` function to detect the start of a new bar on a specified timeframe (e.g., \"1D\" for daily). This allows capturing the `open` price at the beginning of the day and storing the previous day's open.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_timeframe.change",
            "https://www.tradingview.com/pine-script-reference/v6/#var_open"
          ]
        },
        {
          "type": "Functions",
          "heading": "Using ​ `request.security()` ​",
          "remarks": "Using `request.security()` allows accessing actual higher timeframe data feeds, ensuring consistency between chart timeframes. Realtime plots might still repaint if using values like `close` that change intra-bar.",
          "examples": [
            "//@version=6\nindicator(\"Previous and current day open using `request.security()`\", \"\", true, max_lines_count = 500)\nstring periodInput = input.timeframe(\"1D\", \"Higher timeframe\")\n[htfOpen1, htfOpen2, htfTime, htfTimeClose] = request.security(syminfo.tickerid, periodInput, [open[1], open[2], time[1], time_close[1]], lookahead = barmerge.lookahead_on)\n[htfRtOpen, htfRtOpen1] = request.security(syminfo.tickerid, periodInput, [open, open[1]])\nvar line rtOpen  = line.new(na, na, na, na, xloc.bar_time, color = color.lime)\nvar line rtOpen1 = line.new(na, na, na, na, xloc.bar_time, color = color.gray)\nvar int rtStart  = time\nvar int rtEnd    = time_close(periodInput)\nif ta.change(htfTime)\n    line.new(htfTime, htfOpen1, htfTimeClose, htfOpen1, xloc.bar_time, color = color.lime)\n    line.new(htfTime, htfOpen2, htfTimeClose, htfOpen2, xloc.bar_time, color = color.gray)\n    rtStart := time\n    rtEnd   := time_close(periodInput)\nline.set_xy1(rtOpen1, rtStart, htfRtOpen1), line.set_xy2(rtOpen1, rtEnd, htfRtOpen1)\nline.set_xy1(rtOpen,  rtStart, htfRtOpen),  line.set_xy2(rtOpen,  rtEnd, htfRtOpen)\nbgcolor(timeframe.change(periodInput) ? color.new(color.gray, 80) : na)"
          ],
          "description": "Shows how to use `request.security()` to fetch higher timeframe data (e.g., daily `open`) to plot previous and current day's open values that match higher timeframe charts. Uses `lookahead = barmerge.lookahead_on` for historical bars and separate requests for realtime data to mitigate repainting issues.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_request.security",
            "https://www.tradingview.com/pine-script-docs/concepts/repainting/"
          ]
        },
        {
          "type": "Keywords",
          "heading": "Using ​ `timeframe` ​",
          "remarks": "This method is suitable only for simple scripts without drawings. The plotting behavior depends on the \"Wait for timeframe closes\" setting.",
          "examples": [
            "//@version=6\nindicator(\"Previous and current day open using `timeframe`\", \"\", true, timeframe = \"1D\", timeframe_gaps = true)\nplot(open[1], \"Yesterday's Open\", color.red,   2, plot.style_line)\nplot(open,     \"Today's Open\",     color.green, 2, plot.style_line)"
          ],
          "description": "Explains that setting the `timeframe` parameter in the `indicator()` or `strategy()` declaration forces the script to run entirely on the specified timeframe (e.g., \"1D\"). This simplifies plotting daily open values but changes the script's execution behavior, potentially returning values at the close of the higher timeframe bar for historical data.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_indicator",
            "https://www.tradingview.com/support/solutions/43000591555/"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I count the occurrences of a condition in the last x bars?",
          "remarks": "Using unnecessary, large, or nested `for` loops can significantly slow down script execution. `math.sum()` is the recommended approach for counting occurrences over a lookback period. The example uses `math.min(lengthInput, bar_index + 1)` to handle the start of the chart history correctly.",
          "examples": [
            "//@version=6\nindicator(\"Number of occurrences demo\", overlay = false)\nint lengthInput = input.int(100, \"Length\", minval = 1)\n// Condition to count.\nbool isUpBar = close > open\n// Count using a loop (inefficient).\ncountWithLoop(bool condition, int length) =>\n    int count = 0\n    for i = 0 to length - 1\n        if condition[i]\n            count += 1\n    count\n// Count using Pine's built-in function. Can be \"simple\" or \"series\" length.\ncountWithSum(bool condition, int length) =>\n    float result = math.sum(condition ? 1 : 0, length)\n\nfloat v1 = countWithSum(isUpBar,  math.min(lengthInput, bar_index + 1))\nint   v2 = countWithLoop(isUpBar, math.min(lengthInput, bar_index + 1))\nplot(v1, \"Efficient count\",       color.red,   4)\nplot(v2, \"Inefficient count\",     color.black, 1)"
          ],
          "description": "Compares using an inefficient `for` loop versus the efficient built-in `math.sum()` function to count the occurrences of a condition over the last `x` bars. `math.sum()` maintains a running total and is preferred for performance.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#kw_for",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_math.sum",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#simple",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#series",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_na"
          ]
        },
        {
          "type": "Keywords",
          "heading": "How can I implement an on/off switch?",
          "remarks": "The `var` keyword is crucial for maintaining state across bars. The `:=` operator is used for reassigning the persistent variable's value.",
          "examples": [
            "//@version=6\nindicator(\"On/Off condition example\", overlay = true)\nbool upBar = close > open\n// On/off conditions.\nbool triggerOn  = upBar and upBar[1] and upBar[2]\nbool triggerOff = not upBar and not upBar[1]\n// Switch state is saved across bars.\nvar bool onOffSwitch = false\n// Turn the switch on or off, otherwise persist its state.\nonOffSwitch := triggerOn ? true : triggerOff ? false : onOffSwitch\nbgcolor(onOffSwitch ? color.new(color.green, 90) : na)\nplotchar(triggerOn,  \"triggerOn\",  \"▲\", location.belowbar, color.lime, size = size.tiny, text = \"On\")\nplotchar(triggerOff, \"triggerOff\", \"▼\", location.abovebar, color.red,  size = size.tiny, text = \"Off\")"
          ],
          "description": "Demonstrates how to create a persistent on/off state using a boolean variable declared with the `var` keyword. The `var` keyword ensures the variable (`onOffSwitch` in the example) is initialized only once and retains its value across bars unless explicitly reassigned based on trigger conditions (`triggerOn`, `triggerOff`).",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/variable-declarations/#var"
          ]
        },
        {
          "type": "Types",
          "heading": "How can I alternate conditions?",
          "remarks": "Using an `enum` with an `undefined` state is more robust than using a single boolean (which cannot be `na`) or potentially complex logic with two booleans or a string. Enums prevent errors from misspelled or outdated string comparisons.",
          "examples": [
            "//@version=6\nindicator(\"Alternating states\", \"\", true)\nlookback = input.int(2, title=\"Lookback & Lookahead\")\n// Define an enum of allowed pivot types.\nenum PivotType\n    high\n    low\n    undefined\n\nconst color red80 = color.new(color.red, 80)\nconst color green80 = color.new(color.green, 80)\nconst color yellow80 = color.new(color.yellow, 80)\n\n// Define a variable of type PivotType to track the pivot direction.\nvar PivotType lastPivot = PivotType.undefined\n\n// Define pivots.\nfloat pivotLowPrice = ta.pivotlow(lookback, lookback)\nfloat pivotHighPrice = ta.pivothigh(lookback, lookback)\nbool isPivotLow = not na(pivotLowPrice)\nbool isPivotHigh = not na(pivotHighPrice)\n\n// Plot triangles for pivot points.\nplotshape(isPivotLow ? pivotLowPrice : na, \"Low\", shape.triangleup, location.belowbar, color.yellow,\noffset = -lookback, size = size.tiny)\nplotshape(isPivotHigh ? pivotHighPrice : na, \"High\", shape.triangledown, location.abovebar, color.yellow,\noffset = -lookback, size = size.tiny)\n\n// Confirm highs and lows strictly in order. `PivotType.undefined` handles the case where no pivot has yet occurrred.\nbool confirmedLow = isPivotLow and (lastPivot == PivotType.high or lastPivot == PivotType.undefined)\nbool confirmedHigh = isPivotHigh and (lastPivot == PivotType.low or lastPivot == PivotType.undefined)\n\n// Plot larger triangles for confirmed pivots.\nplotshape(confirmedLow ? pivotLowPrice : na, \"Low Confirmed\", shape.triangleup, location.belowbar, color.green,\noffset = -lookback, size = size.normal)\nplotshape(confirmedHigh ? pivotHighPrice : na, \"High Confirmed\", shape.triangledown, location.abovebar, color.red,\noffset = -lookback, size = size.normal)\n\n// Update last pivot direction.\nlastPivot := confirmedLow ? PivotType.low : confirmedHigh ? PivotType.high : lastPivot\n\n// Color the background of the chart based on the direction of the most recent confirmed pivot.\nbgcolor(lastPivot == PivotType.low ? green80 : lastPivot == PivotType.high ? red80 :\nlastPivot == PivotType.undefined ? yellow80 : na)"
          ],
          "description": "Explains how to enforce strict alternation between two states (e.g., high pivot followed only by low pivot, and vice-versa), even if trigger conditions occur out of order. Recommends using an `enum` type variable (declared with `var`) to track the last confirmed state (`high`, `low`, or `undefined` initially).",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/enums/#enums",
            "https://www.tradingview.com/pine-script-docs/migration-guides/to-pine-version-6/#boolean-values-cannot-be-na",
            "https://www.tradingview.com/pine-script-docs/faq/techniques/#how-can-i-accumulate-a-value-for-two-exclusive-states"
          ]
        },
        {
          "type": "Annotations",
          "heading": "Can I merge two or more indicators into one?",
          "remarks": "Also advises checking for compatible scales and non-overlapping variable names, and converting scripts to the same Pine Script® version before merging.",
          "examples": [],
          "description": "Briefly mentions that when merging indicators, ensure there is only one version declaration (e.g., `//@version=6`) and one script declaration (`indicator()` or `strategy()`) in the final script.",
          "related_links": []
        },
        {
          "type": "Functions",
          "heading": "How can I rescale an indicator from one scale to another?",
          "remarks": "Normalizing unbounded data is imperfect as the scale is dynamic, changing as new historical highs/lows occur. The provided `normalize` function is more complete than using `ta.lowest()`/`ta.highest()` over a fixed lookback.",
          "examples": [
            "//@version=6\nindicator(\"Rescaling and normalizing values\", \"\", overlay = false)\n// @function           Rescales a signal with a known scale (bounded) to a new scale.\n// @param src          (series float) The series to rescale.\n// @param oldMin         (simple float) The minimum value of the original signal's scale.\n// @param oldMax         (simple float) The maximum value of the original signal's scale.\n// @param newMin         (simple float) The minimum value of the new scale.\n// @param newMax         (simple float) The maximum value of the new scale.\n// @returns            (float) The rescaled value of the signal.\nrescale(series float src, simple float oldMin, simple float oldMax, simple float newMin, simple float newMax) =>\n    float result = newMin + (newMax - newMin) * (src - oldMin) / math.max(oldMax - oldMin, 10e-10)\n\n// @function        Rescales a signal with an unknown scale (unbounded) using its historical low and high values.\n// @param src       (series float) The series to rescale.\n// @param min       (simple float) The minimum value of the rescaled series.\n// @param max       (simple float) The maximum value of the rescaled series.\n// @returns         (float) The rescaled value of the signal.\nnormalize(series float src, simple float min, simple float max) =>\n    var float historicMin = 10e10\n    var float historicMax = -10e10\n    historicMin := math.min(nz(src, historicMin), historicMin)\n    historicMax := math.max(nz(src, historicMax), historicMax)\n    float result = min + (max - min) * (src - historicMin) / math.max(historicMax - historicMin, 10e-10)\n\n// ————— Plot normalized CCI\ncci = ta.cci(close, 20)\nplot(normalize(cci, 100, 300), \"Normalized CCI\", #2962FF)\n// Arbitrary and inexact equivalent of 100 and -100 levels rescaled to the 100/300 scale.\nband00 = hline(150, \"Lower Band\", color.new(#C0C0C0, 90), hline.style_solid)\nband01 = hline(250, \"Upper Band\", color.new(#C0C0C0, 90), hline.style_solid)\nfill(band01, band00, color.new(#21328F, 80), \"Background\")\n\n// ————— Plot normalized volume in the same region as the rescaled RSI\ncolor volColor = close > open ? #26a69a : #ef5350\nplot(normalize(volume, -100, 100), \"Normalized volume\", volColor, style = plot.style_columns, histbase = -100)\nhline(100,  \"\", color.new(color.gray, 50), hline.style_dashed)\nhline(-100, \"\", color.new(color.gray, 50), hline.style_solid)\n\n// ————— Plot rescaled RSI\nplot(rescale(ta.rsi(close, 14), 0, 100, -100, 100), \"Rescaled RSI\", #8E1599)\nhline(0, \"RSI 50 level\", color.new(color.gray, 70), hline.style_solid)\n// Precise equivalent of 70 and 30 levels rescaled to the -100/100 scale.\nband10 = hline(-40, \"Lower Band\", color.new(#9915FF, 80), hline.style_solid)\nband11 = hline(40,  \"Upper Band\", color.new(#9915FF, 80), hline.style_solid)\nfill(band11, band10, color.new(#9915FF, 90), \"Background\")\n\n// ————— Plot original values in Data Window\nplot(na,               \"═══════════════\",     display = display.data_window)\nplot(cci,               \"Original CCI\",        display = display.data_window)\nplot(volume,            \"Original volume\",     display = display.data_window)\nplot(ta.rsi(close, 14), \"Original RSI\",        display = display.data_window)"
          ],
          "description": "Explains the concepts of rescaling (for bounded data, like RSI 0-100) and normalizing (for unbounded data, like volume or CCI) to display indicators with different value ranges compatibly in the same pane. Provides custom `rescale()` and `normalize()` functions. The `normalize()` function uses historical min/max values tracked across bars.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.cci",
            "https://www.tradingview.com/pine-script-reference/v6/#var_volume",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.lowest",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest"
          ]
        },
        {
          "type": "Keywords",
          "heading": "How can I save a value when an event occurs?",
          "remarks": "Using the assignment operator `=` instead of `:=` inside the `if` block would create a new local variable (shadowing the global one) instead of modifying the persistent variable, which is usually unintended.",
          "examples": [
            "//@version=6\nindicator(\"Save a value when an event occurs\", \"\", true)\nfloat hiHi = ta.highest(high, 5)[1]\nvar float priceAtCross = na\nif ta.crossover(close, hiHi)  // When a crossover occurs, assign the current close price to `priceAtCross`.\n    priceAtCross := close\nplot(hiHi)\nplot(priceAtCross, \"Price At Cross\", color.orange, 3, plot.style_circles)"
          ],
          "description": "Explains that to save a value (e.g., `close` price) specifically when an event (e.g., `ta.crossover`) occurs, a persistent variable declared with `var` should be used. The `:=` reassignment operator must be used inside the conditional block (`if`) to update the persistent variable's value.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/variable-declarations/#var",
            "https://www.tradingview.com/pine-script-reference/v6/#var_bar_index",
            "https://www.tradingview.com/pine-script-docs/language/operators/#-reassignment-operator",
            "https://www.tradingview.com/pine-script-docs/language/operators/#-assignment-operator",
            "https://www.tradingview.com/pine-script-docs/language/conditional-structures/#if-structure"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I count touches of a specific level?",
          "remarks": "Tracking touches on each bar and using `math.sum()` is more efficient than using loops. The example handles up/down touches and gaps separately for robustness.",
          "examples": [
            "//@version=6\nindicator(\"Median Touches\", \"\", overlay = false)\nint medianLengthInput  = input.int(100, \"Median calculation: Number of previous closes\")\nint touchesLengthInput = input.int(50,  \"Number of previous bars to check for price touches\")\n\nfloat median = ta.percentile_nearest_rank(close, medianLengthInput, 50)\n\n// Don\"t count neutral touches when price doesn't move.\nbool barUp = close > open\nbool barDn = close < open\n\n// Bar touches median.\nbool medianTouch    = high    > median and low  < median\nbool gapOverMedian  = high[1] < median and low  > median\nbool gapUnderMedian = low[1]  > median and high < median\n\n// Record touches.\nint medianTouchUp = medianTouch and barUp or gapOverMedian  ? 1 : 0\nint medianTouchDn = medianTouch and barDn or gapUnderMedian ? 1 : 0\n\n// Count touches over the last n bars.\nfloat touchesUp = math.sum(medianTouchUp, touchesLengthInput)\nfloat touchesDn = math.sum(medianTouchDn, touchesLengthInput)\n\n// —————————— Plots\n// Markers\nplotchar(medianTouchUp, \"medianTouchUp\", \"▲\", location.belowbar, color.lime, force_overlay = true)\nplotchar(medianTouchDn, \"medianTouchDn\", \"▼\", location.abovebar, color.red, force_overlay = true)\n// Median\nplot(median, \"Median\", color.orange, force_overlay = true)\n// Base areas.\nplot( touchesUp, \"Touches Up\", color.green,  style = plot.style_columns)\nplot(-touchesDn, \"Touches Dn\", color.maroon, style = plot.style_columns)\n// Exceeding area.\nfloat minTouches     = math.min(touchesUp, touchesDn)\nbool  minTouchesIsUp = touchesUp < touchesDn\nbasePlus  = plot(minTouches, \"Base Plus\", display = display.none)\nhiPlus    = plot(not minTouchesIsUp ? touchesUp : na, \"High Plus\", display = display.none)\nbaseMinus = plot(-minTouches, \"Base Plus\", display = display.none)\nloMinus   = plot(minTouchesIsUp ? -touchesDn : na, \"Low Minus\", display = display.none)\nfill(basePlus,  hiPlus,  color.lime)\nfill(baseMinus, loMinus, color.red)"
          ],
          "description": "Demonstrates counting touches of a specific level (e.g., a median) over a lookback period. It uses boolean conditions to identify touches (including gaps across the level) and assigns 1 or 0 to a series based on the touch direction (up/down). The `math.sum()` function is then used to efficiently count these occurrences over the specified length.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_math.sum"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I know if something is happening for the first time since the beginning of the day?",
          "remarks": "The persistent state method (Method 2) uses a `var` variable to track whether the event has already happened today, resetting it daily.",
          "examples": [
            "//@version=6\nindicator(\"First time today example\", \"\", true)\nbool isUpCandle = close > open\n\n// ————— Method 1.\nint barsSincePreviousUpCandle = ta.barssince(isUpCandle[1])\nint barsSinceStartOfDay = ta.barssince(timeframe.change(\"1D\")) - 1\nbool previousUpCandleWasNotToday = barsSincePreviousUpCandle > barsSinceStartOfDay\nbool isFirstToday1 = isUpCandle and previousUpCandleWasNotToday\nplotchar(isFirstToday1, \"isFirstToday1\", \"•\", location.top, color = color.silver, size = size.normal)\nplot(barsSinceStartOfDay, \"barsSinceStartOfDay\", display=display.data_window)\n\n// ————— Method 2.\nvar bool hadUpCandleToday = false  // This is a persistent state.\nbool     isFirstToday2    = false  // This is a one-off event.\n\nif timeframe.change(\"1D\")  // When the day begins..\n    hadUpCandleToday := false  // we have not yet had an up candle today, so reset the state.\n\nif isUpCandle and not hadUpCandleToday  // If this is the first up candle today..\n    hadUpCandleToday := true  // set the persistent state\n    isFirstToday2    := true  // and update the event.\n\nplotchar(isFirstToday2, \"isFirstToday2\", \"•\", location.top, color = color.yellow, size = size.small)"
          ],
          "description": "Presents two methods to detect if a condition occurs for the first time on the current day:\n1. Using `ta.barssince()`: Check if the bars since the condition last occurred (`ta.barssince(condition[1])`) is greater than the bars since the start of the day (`ta.barssince(timeframe.change(\"1D\")) - 1`).\n2. Using a persistent state (`var bool`): Reset the state variable to `false` at the start of each day (`timeframe.change(\"1D\")`). When the condition occurs, if the state is `false`, trigger the event and set the state to `true` to prevent further triggers that day.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.barssince",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_timeframe.change"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I optimize Pine Script code?",
          "remarks": "Use the Pine Profiler first to identify performance bottlenecks before optimizing.",
          "examples": [],
          "description": "Provides optimization tips for Pine Script® code:\n- Use indicator scripts unless modeling trades (strategies are slower).\n- Understand the execution model and time series.\n- Use `var` for variables initialized with complex/time-consuming operations.\n- Minimize string operations.\n- Prefer built-in functions over custom ones for the same task.\n- Consider alternative logic: e.g., use persistent variables instead of `ta.valuewhen()`; store `bar_index` instead of using `ta.barssince()` when applicable.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/writing/limitations/",
            "https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/",
            "https://www.tradingview.com/pine-script-docs/language/execution-model/",
            "https://www.tradingview.com/pine-script-docs/language/time-series/",
            "https://www.tradingview.com/pine-script-docs/language/variable-declarations/#var",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.valuewhen",
            "https://www.tradingview.com/pine-script-docs/faq/techniques/#how-can-i-save-a-value-when-an-event-occurs",
            "https://www.tradingview.com/pine-script-reference/v6/#var_bar_index",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.barssince",
            "https://www.tradingview.com/pine-script-docs/faq/techniques/#how-to-remember-the-last-time-a-condition-occurred"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I access a stock’s financial information?",
          "remarks": "Users can also add financial indicators via the chart's \"Indicators, Metrics & Strategies\" window.",
          "examples": [],
          "description": "States that the `request.financial()` function can be used in Pine Script® to directly request financial data for stocks.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_request.financial"
          ]
        },
        {
          "type": "Types",
          "heading": "How can I find the maximum value in a set of events?",
          "remarks": "This approach is necessary when the value isn't present on every bar, unlike using `ta.highest()` for continuous series like `high`.",
          "examples": [
            "//@version=6\nindicator(\"Max pivot demo\", \"\", true)\n// Create inputs to specify the pivot legs and the number of last pivots to keep to compare.\nint pivotLengthInput = input.int(5, \"Pivot length\", minval = 1)\nint numPivotsInput   = input.int(3, \"Number of pivots to check\")\n\n// Initialize an array with a size based on the number of recent pivots to evaluate.\nvar array<float> pivotsArray = array.new<float>(numPivotsInput)\n\n// Find the pivot value and set up a condition to verify if a value has been found.\nfloat ph = ta.pivothigh(pivotLengthInput, pivotLengthInput)\nbool newPH = not na(ph)\n\n// When a new pivot is found, add it to the array and discard the oldest value.\nif newPH\n    pivotsArray.push(ph)\n    pivotsArray.shift()\n\n// Display the max value from the array on the chart, along with markers indicating the positions and detection times of the pivot highs.\nplot(pivotsArray.max())\nplotchar(newPH, \"newPH\", \"•\", location.abovebar, offset = - pivotLengthInput)\nplotchar(newPH, \"newPH\", \"▲\", location.top)"
          ],
          "description": "Explains that finding the maximum value of sporadic events (like pivot highs) requires storing these values, typically in an `array`. Demonstrates using a fixed-length array managed as a queue (adding new pivots with `array.push()`, removing old ones with `array.shift()`) and finding the maximum value within the stored pivots using `array.max()`.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_high",
            "https://www.tradingview.com/pine-script-reference/v6/#var_low",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest",
            "https://www.tradingview.com/pine-script-docs/language/arrays/",
            "https://www.tradingview.com/pine-script-docs/language/arrays/#using-an-array-as-a-queue",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_array.max"
          ]
        },
        {
          "type": "Keywords",
          "heading": "How can I reset a sum on a condition?",
          "remarks": "The `var` keyword initializes the sum variable once. `+=` adds to the sum on each bar. `:=` is used for conditional reassignment (resetting). The example uses `_` to discard an unused return value from `ta.macd()`.",
          "examples": [
            "//@version=6\nindicator(\"Reset sum on condition example\", overlay = false)\nconst color TEAL = color.new(color.teal, 50)\nconst color RED  = color.new(color.red,  50)\n\n[macdLine, signalLine, _] = ta.macd(close, 12, 26, 9)\nbool crossUp = ta.crossover(macdLine,  signalLine)\nbool crossDn = ta.crossunder(macdLine, signalLine)\nbool doReset = crossUp or crossDn\n\nvar float cumulativeVolume = na\ncumulativeVolume += volume  // On every bar, we sum the volume.\ncumulativeVolume := doReset ? 0. : cumulativeVolume  // But when we get a cross, we reset it to zero.\n\nplot(cumulativeVolume, \"Cumulative volume\", close >= open ? TEAL : RED, 1, plot.style_columns)\nplotshape(crossUp, \"crossDn\", shape.arrowup,   location.top, color.lime)\nplotshape(crossDn, \"crossUp\", shape.arrowdown, location.top, color.fuchsia)"
          ],
          "description": "Demonstrates how to calculate a cumulative sum (e.g., volume) and reset it based on a condition (e.g., MACD crossover). It uses a persistent variable declared with `var` to hold the sum, the `+=` operator to accumulate the value on each bar, and the `:=` operator within a conditional check to reset the sum to zero when the condition is met.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/language/variable-declarations/#var",
            "https://www.tradingview.com/pine-script-reference/v6/#var_volume",
            "https://www.tradingview.com/pine-script-reference/v6/#fun_ta.macd",
            "https://www.tradingview.com/pine-script-docs/language/type-system/#tuples",
            "https://www.tradingview.com/pine-script-docs/language/variable-declarations/#using-an-underscore-_-as-an-identifier"
          ]
        },
        {
          "type": "Keywords",
          "heading": "How can I accumulate a value for two exclusive states?",
          "remarks": "This demonstrates using events to control persistent states (`var bool`). Explicitly defining state transitions and reset conditions is important. Using `enum` (as mentioned in another FAQ entry) is an alternative for managing exclusive states.",
          "examples": [
            "//@version=6\nindicator(\"Cumulative volume\", \"\")\nbool upEvent = ta.rising(close,  2)\nbool dnEvent = ta.falling(close, 2)\n\nvar bool upState = false, var bool dnState = false\n// When the right event occurs, turn the state on; when a counter-event occurs, turn it off; otherwise, persist it.\nupState := upEvent ? true : dnEvent ? false : upState\ndnState := upEvent ? false : dnEvent ? true : dnState\n\nvar float volUp = na, var float volDn = na\nif upState  // For every bar that we are in the up state,\n    volUp += volume  // sum the up volume.\nif dnState\n    volDn += volume\n\nif upEvent  // If we change state to up,\n    volDn := 0  // reset the down volume.\nif dnEvent\n    volUp := 0\n\nplot(+volUp, \"Up Volume\", color.green,  4, plot.style_columns)\nplot(-volDn, \"Dn Volume\", color.maroon, 4, plot.style_columns)\nplotchar(upEvent, \"Up Event\", \"▲\", location.bottom, color.green,  size = size.tiny)\nplotchar(dnEvent, \"Dn Event\", \"▼\", location.top,    color.maroon, size = size.tiny)\nbgcolor(upState ? color.new(color.green, 90) : dnState ? color.new(color.red, 90) : na)"
          ],
          "description": "Illustrates managing two mutually exclusive states (e.g., a buy state and a sell state) using two persistent boolean variables (`var bool upState`, `var bool dnState`). Events (`upEvent`, `dnEvent`) trigger transitions between states. Accumulation (e.g., `volUp += volume`) happens only when the corresponding state is active, and the counter-accumulation is reset (`volDn := 0`) upon state change.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#var_volume",
            "https://www.tradingview.com/pine-script-docs/language/enums/#enums",
            "https://www.tradingview.com/pine-script-docs/faq/techniques/#how-can-i-alternate-conditions",
            "https://www.tradingview.com/pine-script-reference/v6/#var_close",
            "https://www.tradingview.com/pine-script-docs/faq/techniques/#how-can-i-implement-an-onoff-switch"
          ]
        },
        {
          "type": "Functions",
          "heading": "How can I organize my script’s inputs in the Settings/Inputs tab?",
          "remarks": "Tips include ordering inputs logically, using dropdowns (`options`) instead of multiple checkboxes for exclusive choices, providing appropriate min/max/step values, and using `input.string` with options like \"On\"/\"Off\" compared to a constant to create an indented boolean-like input. Unicode characters might render differently across platforms.",
          "examples": [
            "//@version=6\nindicator(\"Inputs\", overlay = true)\n// Defining options strings improves script readability.\n// It also enables the creation of boolean variables by comparing these constants with user input strings in a single line of code.\nstring EQ1 = \"On\"\nstring EQ2 = \"Off\"\n\n// The `GRP*` strings used for group headers demonstrate using ASCII characters to create a visual boundary,\n// making it easier for users to differentiate between different sections in the menu.\n\n// Group 1 demonstrates inline inputs that do not align vertically in the menu.\nstring GRP1 = \"════════════ Settings ═════════════\" // ASCII 205\nfloat  ao1SrcInput    = input.source(close, \"AO source\",      inline = \"11\", group = GRP1)\nint    ao1LenInput    = input.int(14,       \"Length\",         inline = \"11\", group = GRP1)\nfloat  long1SrcInput  = input.source(close, \"Signal source\", inline = \"12\", group = GRP1)\nint    long1LenInput  = input.int(3,        \"Length\",         inline = \"12\", group = GRP1)\n\n// In Group 2, the title of `ao2SrcInput` is padded with three Unicode EN spaces (U+2002) to compensate for the misalignment.\nstring GRP2           = \"──────────── Settings ────────────\" // ASCII 196\nfloat  ao2SrcInput    = input.source(close, \"AO source   \",  inline = \"21\", group = GRP2)\nint    ao2LenInput    = input.int(14,       \"Length\",         inline = \"21\", group = GRP2)\nfloat  long2SrcInput  = input.source(close, \"Signal source\", inline = \"22\", group = GRP2)\nint    long2LenInput  = input.int(3,        \"Length\",         inline = \"22\", group = GRP2)\n\n// This configuration uses Unicode white space characters to indent input sub-sections. We use Em space ( ): 8195 (0x2003).\nstring GRP3           = \"————————————— Settings ———————————————\" // ASCII 151 (Em dash)\nfloat  level1Input    = input.float(65.,    \"First level\",               group = GRP3)\nfloat  level2Input    = input.float(65.,    \"  Second Level\",            group = GRP3)\nbool   level3Input    = input.string(EQ1,   \"    Checkbox equivalent\",   group = GRP3, options = [EQ1, EQ2]) == EQ1\nfloat  level4Input    = input.float(65.,    \"Widest Legend            \", group = GRP3)\n\n// These options demonstrate the use of the `inline` parameter to create structured blocks of inputs that are relevant to one another.\nstring GRP4 = \"------------------------ Settings ----------------------------\" // ASCII 45 (dash)\nbool   showMa1Input   = input(true,          \"MA №1\", inline = \"1\", group = GRP4)\nstring ma1TypeInput   = input.string(\"SMA\", \"\",      inline = \"1\", group = GRP4, options = [\"SMA\", \"EMA\", \"SMMA (RMA)\", \"WMA\", \"VWMA\"])\nfloat  ma1SourceInput = input(close,         \"\",      inline = \"1\", group = GRP4)\nint    ma1LengthInput = input.int(20,        \"\",      inline = \"1\", group = GRP4, minval = 1)\ncolor  ma1ColorInput  = input(#f6c309,      \"\",      inline = \"1\", group = GRP4)\n\nbool   showMa2Input   = input(true,          \"MA №2\", inline = \"2\", group = GRP4)\nstring ma2TypeInput   = input.string(\"SMA\", \"\",      inline = \"2\", group = GRP4, options = [\"SMA\", \"EMA\", \"SMMA (RMA)\", \"WMA\", \"VWMA\"])\nfloat  ma2SourceInput = input(close,         \"\",      inline = \"2\", group = GRP4)\nint    ma2LengthInput = input.int(50,        \"\",      inline = \"2\", group = GRP4, minval = 1)\ncolor  ma2ColorInput  = input(#fb9800,      \"\",      inline = \"2\", group = GRP4)\n\nbool   showMa3Input   = input(true,          \"MA №3\", inline = \"3\", group = GRP4)\nstring ma3TypeInput   = input.string(\"SMA\", \"\",      inline = \"3\", group = GRP4, options = [\"SMA\", \"EMA\", \"SMMA (RMA)\", \"WMA\", \"VWMA\"])\nfloat  ma3SourceInput = input(close,         \"\",      inline = \"3\", group = GRP4)\nint    ma3LengthInput = input.int(100,       \"\",      inline = \"3\", group = GRP4, minval = 1)\ncolor  ma3ColorInput  = input(#fb6500,      \"\",      inline = \"3\", group = GRP4)\n\n// @function           Calculates various types of moving averages for the `source` based on the specified `maType`.\n// @param series        (series float) Series of values to process.\n// @param length        (simple int) Number of bars (length).\n// @param maType        (simple string) The type of moving average to calculate.\n//                      Options are \"SMA\", \"EMA\", \"SMMA (RMA)\", \"WMA\", and \"VWMA\".\n// @returns             (float) The moving average of the `source` for `length` bars back.\nma(series float source, simple int length, simple string maType) =>\n    switch maType\n        \"SMA\"        => ta.sma(source,  length)\n        \"EMA\"        => ta.ema(source,  length)\n        \"SMMA (RMA)\" => ta.rma(source,  length)\n        \"WMA\"        => ta.wma(source,  length)\n        \"VWMA\"       => ta.vwma(source, length)\n        =>               na\n\n// Calculate the moving averages with the user-defined settings.\nfloat ma1 = ma(ma1SourceInput, ma1LengthInput, ma1TypeInput)\nfloat ma2 = ma(ma2SourceInput, ma2LengthInput, ma2TypeInput)\nfloat ma3 = ma(ma3SourceInput, ma3LengthInput, ma3TypeInput)\n\n// Plot the moving averages, if each checkbox is enabled.\nplot(showMa1Input ? ma1 : na, \"MA №1\", ma1ColorInput)\nplot(showMa2Input ? ma2 : na, \"MA №2\", ma2ColorInput)\nplot(showMa3Input ? ma3 : na, \"MA №3\", ma3ColorInput)"
          ],
          "description": "Provides techniques for organizing script inputs in the Settings/Inputs tab using parameters of the `input()` function and its variants (`input.int`, `input.source`, etc.). Techniques include:\n- Grouping inputs under section headers using the `group` parameter.\n- Creating visual separators in group headers using ASCII characters.\n- Indenting sub-sections using Unicode whitespace characters (e.g., Em space).\n- Aligning inline inputs vertically using Unicode space padding (e.g., EN space).\n- Placing multiple related inputs on a single line using the `inline` parameter.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v6/#fun_input",
            "https://jkorpela.fi/chars/spaces.html",
            "https://www.tradingview.com/pine-script-reference/v6/#type_float",
            "https://www.tradingview.com/pine-script-reference/v6/#type_int"
          ]
        },
        {
          "type": "Annotation",
          "heading": "Compiler Annotations",
          "remarks": "This annotation tells the compiler the script will use version 5 of Pine Script.",
          "examples": [
            "//@version=5"
          ],
          "description": "Special comments starting with `//@` that provide instructions to the Pine Script® compiler. The `version` annotation specifies the Pine Script® language version the script uses.",
          "related_links": [
            "https://www.tradingview.com/pine-script-docs/v5/language/script-structure/#compiler-annotations"
          ]
        },
        {
          "type": "Function",
          "heading": "Functions",
          "remarks": "`indicator()` defines the script name. `ta.ema()` calculates the Exponential Moving Average. `plot()` outputs a variable to the chart. `input()` creates a user-configurable input in the script's settings. `ta.macd()` is a built-in function to calculate MACD values, returning multiple results (MACD line, signal line, histogram line).",
          "examples": [
            "indicator(\"MACD #1\")",
            "ta.ema(close, fast)",
            "plot(macd, color = color.blue)",
            "input(12, \"Fast length\")",
            "[macdLine, signalLine, histLine] = ta.macd(close, fastInput, slowInput, 9)"
          ],
          "description": "Reusable blocks of code that perform specific tasks. Pine Script® has built-in functions (like `indicator`, `ta.ema`, `plot`, `input`, `ta.macd`) and allows user-defined functions. Functions are called with arguments enclosed in parentheses. Some functions return multiple values.",
          "related_links": [
            "https://www.tradingview.com/pine-script-reference/v5/#fun_ta%7Bdot%7Dmacd",
            "https://www.tradingview.com/pine-script-reference/v5/#fun_input"
          ]
        },
        {
          "type": "Variable",
          "heading": "Variables",
          "remarks": "Variables can hold different types of data, like integers (`fast`, `slow`), calculation results (`fastMA`, `slowMA`, `macd`, `signal`), or values from user inputs (`fastInput`, `slowInput`). The `close` variable is a built-in series representing the closing price of bars. Multiple variables can be assigned values from functions returning multiple results using square brackets `[]`.",
          "examples": [
            "fast = 12",
            "slow = 26",
            "fastMA = ta.ema(close, fast)",
            "slowMA = ta.ema(close, slow)",
            "macd = fastMA - slowMA",
            "signal = ta.ema(macd, 9)",
            "fastInput = input(12, \"Fast length\")",
            "slowInput = input(26, \"Slow length\")",
            "[macdLine, signalLine, histLine] = ta.macd(close, fastInput, slowInput, 9)"
          ],
          "description": "Named containers used to store data, such as calculation results, input values, or series data. Variables are defined using the `=` assignment operator.",
          "related_links": []
        },
        {
          "type": "Operator",
          "heading": "Operators",
          "remarks": "The example shows the subtraction operator `-` used to calculate the difference between two variables (`fastMA` and `slowMA`).",
          "examples": [
            "macd = fastMA - slowMA"
          ],
          "description": "Symbols that perform operations on variables and values.",
          "related_links": []
        }
      ]
    }
  ]